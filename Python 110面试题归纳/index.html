<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Python面试题归纳 | ZhangXiong</title>
<meta name="description" content="当地比较有趣的一类人." />
<link rel="shortcut icon" href="https://xiong-zh.github.io/favicon.ico?v=1582985743430">
<link href="https://cdn.remixicon.com/releases/v1.3.1/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">

<link rel="stylesheet" href="https://xiong-zh.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Python面试题归纳 | ZhangXiong - Atom Feed" href="https://xiong-zh.github.io/atom.xml">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-156420077-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-156420077-1');
</script>


  </head>
  <body>
    <div class="site-nav has-cover">
      <div class="head">
  <div class="inner">
    <a class="site-name" href="https://xiong-zh.github.io">
        <span>ZhangXiong</span>
    </a>
    <label class="burger" for="burger"></label>
    <input id="burger" type="checkbox">
    <button class="burger">
      <div>
        <span></span>
        <span></span>
      </div>
    </button>
    <nav class="info_nav">
      
        
          <a href="/">回到首页</a>
        
      
        
          <a href="/archives">文章归档</a>
        
      
        
          <a href="/tags">所有标签</a>
        
      
        
          <a href="/documents/" target="_blank">后端图谱</a>
        
      
        
          <a href="/friends/">友情链接</a>
        
      
        
          <a href="/about">关于</a>
        
      
    </nav>
  </div>
</div>
    </div>
    <article role="main" class="hentry has-cover">
      
        <div class="entry-cover js-cover" data-src="http://picture.zhangxiong.net/images/blog_picture/cover/061.jpg" data-width="900" data-height="423" style="background-image:url(http://picture.zhangxiong.net/images/blog_picture/cover/061.jpg); height: 80vw;">
          <h1 class="post-title">Python面试题归纳</h1>
        </div>
      
      <h1 class="entry-title" itemprop="headline">Python面试题归纳</h1>
      <div class="entry-meta">
        <time class="updated" datetime="2020-01-20 13:14:59">2020-01-20</time>
        <span class="author vcard">
          37 min read
        </span>
      </div>
      <div class="post-content yue">
        <p>提高 python 运行效率的方法：<br>
1、使用生成器，因为可以节约大量内存<br>
2、循环代码优化，避免过多重复代码的执行<br>
3、核心模块用Cython  PyPy等，提高效率<br>
4、多进程、多线程、协程<br>
5、多个if elif条件判断，可以把最有可能先发生的条件放到前面写，这样可以减少程序判断的次数，提高效率</p>
<!--more-->
<h2 id="110-道-python-面试笔试题汇总">110 道 Python 面试笔试题汇总</h2>
<p>一行代码实现 1--100 之和</p>
<pre><code>sum(range(0, 101))  # 5050
</code></pre>
<p>如何在一个函数内部修改全局变量</p>
<pre><code>num = 5
def func():
    global num
    num = 4
func()
print(num)  # 4
</code></pre>
<p>列出 5 个常用 Python 标准库？</p>
<pre><code>os：提供了不少与操作系统相关联的函数
sys：通常用于命令行参数
re：正则匹配
math：数学运算
datetime：处理日期时间
</code></pre>
<p>如何合并两个字典？</p>
<pre><code>    name = {'name': 'Gage'}
    age = {'age': 25}
    name.update(age)
    print(name)  # {'name': 'Gage', 'age': 25}
</code></pre>
<p>谈下 Python 的 GIL？</p>
<blockquote>
<p>GIL 是 Python 的全局解释器锁，同一进程中假如有多个线程运行，一个线程在运行 Python 程序的时候会占用 Python 解释器（加了一把锁即 GIL），使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行。</p>
</blockquote>
<p>多进程中因为每个进程都能被系统分配资源，相当于每个进程有了一个 Python 解释器，所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大。</p>
<p>Python 实现列表去重的方法？</p>
<pre><code>    num_list = [1, 3, 1, 5, 3, 6, 1]
    print([num for num in set(num_list)])  # [1, 3, 5, 6]
</code></pre>
<p>fun(args,kwargs)中的args, kwargs 什么意思？</p>
<blockquote>
<p>如果你有其他语言基础的话，你应该听说过重载的概念，对，Python 为了避免这种繁琐的情况发生，引入了 args 和 kwargs；args 用来接受非键值对的数据，即元组类型，而 kwargs 则用来接受键值对数据，即字典类型。</p>
</blockquote>
<p>Python2 和 Python3 的 range（100）的区别？</p>
<pre><code>Python2 返回列表，Python3 返回迭代器，节约内存。
</code></pre>
<p>生成一个 16 位的随机字符串？</p>
<pre><code>    import string
    print(''.join((random.choice(string.printable)) for i in range(16)))   # X{|op?_gSM-ra%N\  
</code></pre>
<p>一句话解释什么样的语言能够用装饰器?</p>
<pre><code> 函数可以作为参数传递
</code></pre>
<p>Python 内建数据类型有哪些？</p>
<pre><code>整型--int
布尔型--bool
字符串--str
列表--list
元组--tuple
字典--dict
</code></pre>
<p>简述面向对象中<strong>new</strong>和<strong>init</strong>区别？</p>
<pre><code>    1、__new__至少要有一个参数 cls，代表当前类，此参数在实例化时由Python解释器自动识别。
    2、__new__必须要有返回值，返回实例化出来的实例，这点在自己实现__new__时要特别注意，可以 return 父类（通过 super(当前类名, cls)）__new__出来的实例，或者直接是 object 的__new__出来的实例。
    3、__init__有一个参数 self，就是这个__new__返回的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值。
    4、如果__new__创建的是当前类的实例，会自动调用__init__函数，通过 return 语句里面调用的__new__函数的第一个参数是 cls 来保证是当前类实例，如果是其他类的类名，；那么实际创建返回的就是其他类的实例，其实就不会调用当前类的__init__函数，也不会调用其他类的__init__函数。
</code></pre>
<p>简述 with 方法打开处理文件帮我我们做了什么？</p>
<pre><code>打开文件在进行读写的时候可能会出现一些异常状况，如果按照常规的f.open 写法，我们需要 try,except,finally，做异常判断，并且文件最终不管遇到什么情况，都要执行 finally f.close() 关闭文件，with 方法帮我们实现了 finally 中 f.close。
</code></pre>
<p>列表[1,2,3,4,5]，请使用 map() 函数输出[1,4,9,16,25]，并使用列表推导式提取出大于 10 的数，最终输出 [16,25]？</p>
<pre><code>num_list = [1, 2, 3, 4, 5]
print([x for x in list(map(lambda x: x * x, num_list)) if x &gt; 10])  # [16,25]
</code></pre>
<p>python 中生成随机整数、随机小数、0--1 之间小数方法？</p>
<pre><code>import random
print(random.randint(1, 10))  # 随机整数
print(random.random())  # 0-1随机小数
print(random.uniform(2, 6)) # 指定范围[2-6]随机小数
</code></pre>
<p>避免转义给字符串加哪个字母表示原始字符串？</p>
<pre><code>    b'input\n' # bytes字节符，打印以b开头。
    输出：
    b'input\n'
    --------------------------------------
    r'input\n' # 非转义原生字符，经处理'\n'变成了'\\'和'n'。也就是\n表示的是两个字符，而不是换行。
    输出：
    'input\\n'
    --------------------------------------
    u'input\n' # unicode编码字符，python3默认字符串编码方式。
    输出：
    'input\n'
</code></pre>
<div class="nam">Python</div>，用正则匹配出标签里面的内容（“Python”），其中 class 的类名是不确定的。
```
    import re
    s = '<div class="nam">Python</div>'
    print(re.findall(r'<div class=".*">(.*?)</div>', s)) #['Python']
```
<p>Python 中断言方法举例？</p>
<pre><code>    age = 10
    assert 0 &lt; age &lt; 10
    --------------------
    Traceback (most recent call last):
      File &quot;F:/MxOnline/110/exam.py&quot;, line 69, in &lt;module&gt;
        assert 0 &lt; age &lt; 10
    AssertionError
</code></pre>
<p>dict 中 fromkeys 的用法</p>
<pre><code>keys = ('info',)
print(dict.fromkeys(keys, ['Gage', '25', 'man'])) # {'info': ['Gage', '25', 'man']}
</code></pre>
<p>请用正则表达式输出汉字</p>
<pre><code>    import re
    a = &quot;not 404 found 中国 2018 我爱你&quot;
    r1 = '[a-zA-Z0-9’!&quot;#$%&amp;\'()*+,-./:;&lt;=&gt;?@，。?★、…【】《》？“”‘’！[\\]^_`{|}~]+\s?'
    print(re.sub(r1, '', a))  # 中国 我爱你
</code></pre>
<p>Python2 和 Python3 区别？列举 5 个</p>
<pre><code> 1.去除了&lt;&gt;，全部改用!=
 2.xrange() 改名为range()
 3.内存操作cStringIO改为StringIO
 4.加入nonlocal 作用：可以引用外层非全局变量
 5.zip()、map()和filter()都返回迭代器，而不是生成器，更加节约内存
</code></pre>
<p>列出 Python 中可变数据类型和不可变数据类型，为什么？</p>
<pre><code> 1、可变数据类型：list、dict、set
 2、不可变数据类型：int/float、str、tuple
 3、原理：可变数据类型即公用一个内存空间地址，不可变数据类型即每产生一个对象就会产生一个内存地址
</code></pre>
<p>dict 的内部实现？</p>
<blockquote>
<p>在 Python 中，字典是通过哈希表实现的。也就是说，字典是一个数组，而数组的索引是键经过哈希函数处理后得到的。哈希函数的目的是使键均匀地分布在数组中。由于不同的键可能具有相同的哈希值，即可能出现冲突，高级的哈希函数能够使冲突数目最小化。</p>
</blockquote>
<p>s = &quot;ajldjlajfdljfddd&quot;，去重并从小到大排序输出&quot;adfjl&quot;？</p>
<pre><code>s1 = &quot;ajldjlajfdljfddd&quot;
print(''.join(sorted(set(s1))))  # adfjl
</code></pre>
<p>用 lambda 函数实现两个数相乘？</p>
<pre><code>mul = lambda x, y: x*y
print(mul(2, 4))  # 8
</code></pre>
<p>字典根据键从小到大排序？</p>
<pre><code>    info = {'name': 'Gage', 'age': 25, 'sex': 'man'}
    print(sorted(info.items(), key=lambda x: x[0])) # [('age', 25), ('name', 'Gage'), ('sex', 'man')]
</code></pre>
<p>Python 获取当前日期？</p>
<pre><code>    import time
    import datetime
    print(datetime.datetime.now())
    print(time.strftime('%Y-%m-%d %H:%M:%S')) # 2019-03-13 11:33:56
</code></pre>
<p>获取请求头的参数？</p>
<pre><code>    from urllib.parse import urlparse, parse_qs
    s2 = &quot;/get_feed_list?version_name=5.0.9.0&amp;device_id=12242channel_name=google&quot;
    def spiltline(value):
        url = {'site': urlparse(value).path}
        url.update(parse_qs(urlparse(value).query))
        return url
     --------------------------------------
     {'site': '/get_feed_list', 'version_name': ['5.0.9.0'], 'device_id': ['12242channel_name=google']}
</code></pre>
<p>例举五条 PEP8 规范</p>
<pre><code>不要在行尾加分号, 也不要用分号将两条命令放在同一行
不要使用反斜杠连接行
不要在返回语句或条件语句中使用括号
顶级定义之间空2行, 方法定义之间空1行，顶级定义之间空两行
如果一个类不继承自其它类, 就显式的从object继承
</code></pre>
<p>Python 语言的运行机制</p>
<figure data-type="image" tabindex="1"><img src="https://images.gitbook.cn/4408a5a0-4484-11e9-bd1f-43448f7c081f" alt="PVM" loading="lazy"></figure>
<p>Fibonacci 数列</p>
<pre><code>    def fab(n):
        a, b = 0, 1
        while n:
            yield b
            a, b = b, a+b
            n -= 1
</code></pre>
<pre><code>
</code></pre>
<p>Python 三目运算</p>
<pre><code># 若果 a&gt;b 成立  就输出  a-b  否则 a+b
h = a-b if a&gt;b else a+b
</code></pre>
<p>单例模式</p>
<pre><code>     class Single(object):
        __isstance = None
        __first_init = False
        def __new__(cls, *args, **kwargs):
            if not cls.__isstance:
                cls.__isstance = object.__new__(cls)
            return cls.__isstance
        def __init__(self, name):
            if not self.__first_init:
                self.name = name
                Singleton.__first_init = True
</code></pre>
<p>正则匹配优先级</p>
<figure data-type="image" tabindex="2"><img src="https://images.gitbook.cn/e143ce80-4484-11e9-8cff-9373d208f277" alt="enter image description here" loading="lazy"></figure>
<p>递归</p>
<pre><code>     def digui(n):
        if n == 1:
            return 1
        else:
            return (n * digui(n-1)
</code></pre>
<pre><code>
</code></pre>
<p>统计字符串每个单词出现的次数</p>
<pre><code>from collections import Counter
s3 = &quot;kjalfj;ldsjafl;hdsllfdhg;lahfbl;hl;ahlf;h&quot;
print(Counter(s3))
</code></pre>
<p>正则 re.complie 作用</p>
<blockquote>
<p>re.compile 是将正则表达式编译成一个对象，加快速度，并重复使用</p>
</blockquote>
<p>filter 方法求出列表所有奇数并构造新列表，a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p>
<pre><code>    a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    print(list(filter(lambda x: x % 2, a)))
    ---------------------
    Counter({'l': 9, ';': 6, 'h': 6, 'f': 5, 'a': 4, 'j': 3, 'd': 3, 's': 2, 'k': 1, 'g': 1, 'b': 1})
</code></pre>
<p>列表推导式求列表所有奇数并构造新列表，a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p>
<pre><code>    print([x for x in a if x % 2])
</code></pre>
<p>a=（1，）b=(1)，c=(&quot;1&quot;) 分别是什么类型的数据？</p>
<pre><code>    print(type((1, ))) # tuple
    print(type((1))) # int
    print(type((&quot;1&quot;))) # str
</code></pre>
<p>两个列表[1,5,7,9]和[2,2,6,8]合并为[1,2,2,3,6,7,8,9]</p>
<pre><code>l1 = [1, 5, 7, 9]
l2 = [2, 2, 6, 8]
l1.extend(l2)
</code></pre>
<p>用 python 删除文件和用 linux 命令删除文件方法</p>
<pre><code>python：os.remove(文件名)
linux: rm 文件名
</code></pre>
<p>logging 模块的使用？</p>
<pre><code>    import logging
    logging.basicConfig(level = logging.INFO,format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    logger = logging.getLogger(__name__)

    logger.info(&quot;Start print log&quot;)
    logger.debug(&quot;Do something&quot;)
    logger.warning(&quot;Something maybe fail.&quot;)
    logger.info(&quot;Finish&quot;)
</code></pre>
<p>写一段自定义异常代码</p>
<pre><code>    #自定义异常用raise抛出异常
    def fn():
        try:
            for i in range(5):
                if i&gt;2:
                    raise Exception(&quot;数字大于2了&quot;)
        except Exception as ret:
            print(ret)
    fn()    # 数字大于2了
</code></pre>
<p>正则表达式匹配中，（.<em>）和（.</em>?）匹配区别？</p>
<pre><code>    #（.*）是贪婪匹配，会把满足正则的尽可能多的往后匹配
    #（.*?）是非贪婪匹配，会把满足正则的尽可能少匹配
    s = &quot;&lt;a&gt;哈哈&lt;/a&gt;&lt;a&gt;呵呵&lt;/a&gt;&quot;
    import re
    res1 = re.findall(&quot;&lt;a&gt;(.*)&lt;/a&gt;&quot;, s)
    print(&quot;贪婪匹配&quot;, res1)
    res2 = re.findall(&quot;&lt;a&gt;(.*?)&lt;/a&gt;&quot;, s)
    print(&quot;非贪婪匹配&quot;, res2)
    -------------------------
    输出：
    贪婪匹配 ['哈哈&lt;/a&gt;&lt;a&gt;呵呵']
    非贪婪匹配 ['哈哈', '呵呵']
</code></pre>
<p>[[1,2],[3,4],[5,6]]一行代码展开该列表，得出[1,2,3,4,5,6]</p>
<pre><code>    a=[[1,2],[3,4],[5,6]]
    print([j for i in a for j in i])
</code></pre>
<p>x=&quot;abc&quot;,y=&quot;def&quot;,z=[&quot;d&quot;,&quot;e&quot;,&quot;f&quot;]，分别求出 x.join(y) 和 x.join(z) 返回的结果</p>
<pre><code>    #join()括号里面的是可迭代对象，x插入可迭代对象中间，形成字符串，结果一致
    x=&quot;abc&quot;
    y=&quot;def&quot;
    z=[&quot;d&quot;,&quot;e&quot;,&quot;f&quot;]
    a=x.join(y)
    b=x.join(z)
    print(a)
    print(b)
    均输出：
    dabceabcf
</code></pre>
<p>举例说明异常模块中 try except else finally 的相关意义</p>
<pre><code>    try..except..else没有捕获到异常，执行else语句
    try..except..finally不管是否捕获到异常，都执行finally语句
</code></pre>
<p>python 中交换两个数值</p>
<pre><code>a,b=1,2
a,b=b,a
</code></pre>
<p>举例说明 zip() 函数用法</p>
<pre><code>    list1 = [1, 2, 3, 5]
    list2 = [4, 5, 6]
    zipped = zip(list1, list2)
    print(list(zipped))  # [(1, 4), (2, 5), (3, 6)]
    # print(list(zip(*zipped)))  # [(1, 2, 3), (4, 5, 6)]
</code></pre>
<p>a=&quot;张明 98分&quot;，用 re.sub，将 98 替换为 100</p>
<pre><code>    import re
    a=&quot;张明 98分&quot;
    ret=re.sub(r&quot;\d+&quot;,&quot;100&quot;,a)
    print(ret)    
</code></pre>
<p>a=&quot;hello&quot;和b=&quot;你好&quot;编码成 bytes 类型</p>
<pre><code>    a=b&quot;hello&quot;        
    b=&quot;你好&quot;.encode()
    print(a,b)
    print(type(a),type(b))
</code></pre>
<p>[1,2,3]+[4,5,6]的结果是多少？</p>
<pre><code>print([1,2,3]+[4,5,6]) # [1, 2, 3, 4, 5, 6]
</code></pre>
<p>提高 python 运行效率的方法</p>
<pre><code>1、使用生成器，因为可以节约大量内存
2、循环代码优化，避免过多重复代码的执行
3、核心模块用Cython  PyPy等，提高效率
4、多进程、多线程、协程
5、多个if elif条件判断，可以把最有可能先发生的条件放到前面写，这样可以减少程序判断的次数，提高效率
</code></pre>
<p>遇到 bug 如何处理</p>
<pre><code>1、细节上的错误，通过print（）打印，能执行到print（）说明一般上面的代码没有问题，分段检测程序是否有问题，如果是js的话可以alert或console.log
2、如果涉及一些第三方框架，会去查官方文档或者一些技术博客。
3、对于bug的管理与归类总结，一般测试将测试出的bug用teambin等bug管理工具进行记录，然后我们会一条一条进行修改，修改的过程也是理解业务逻辑和提高自己编程逻辑缜密性的方法，我也都会收藏做一些笔记记录。
4、导包问题、城市定位多音字造成的显示错误问题
</code></pre>
<p>list=[2,3,5,4,9,6]，从小到大排序，不许用 sort，输出[2,3,4,5,6,9]</p>
<pre><code>    def quicksort(list):
        if len(list)&lt;2:
            return list
        else:
            midpivot = list[0]
            lessbeforemidpivot = [i for i in list[1:] if i&lt;=midpivot]
            biggerafterpivot = [i for i in list[1:] if i &gt; midpivot]
            finallylist = quicksort(lessbeforemidpivot)+[midpivot]+quicksort(biggerafterpivot)
            return finallylist

    print quicksort([2,3,5,4,9,6])
</code></pre>
<p>两数相除保留两位小数</p>
<pre><code>print(round(5/3, 2)) # 1.67
</code></pre>
<p>正则匹配，匹配日期 2018-03-20</p>
<pre><code>    import re
    print(re.findall('((?:(?:[2468][048]00|[13579][26]00|[1-9]\d0[48]|[1-9]\d[2468][048]|[1-9]\d[13579][26])/(?:0?2/(?:0[1-9]|0?[1-9](?=\D)|[12]\d)))|(?:(?:[12]\d{3})/(?:(?:0?2/(?:0[1-9]|0?[1-9](?=\D)|1\d|2[0-8]))|(?:0?[3578]/(?:0[1-9]|0?[1-9](?=\D)|[12]\d|3[01]))|(?:0?[469]/(?:0[1-9]|0?[1-9](?=\D)|[12]\d|30))|(?:1[02]/(?:0[1-9]|0?[1-9](?=\D)|[12]\d|3[01]))|(?:11/(?:0[1-9]|0?[1-9](?=\D)|[12]\d|30))|(?:0?1/(?:0[1-9]|0?[1-9](?=\D)|[12]\d|3[01])))))', 'Date：2018/03/20'))
</code></pre>
<p>使用 pop 和 del 删除字典中的&quot;name&quot;字段，dic={&quot;name&quot;:&quot;zs&quot;,&quot;age&quot;:18}</p>
<pre><code>dic = {&quot;name&quot;: &quot;zs&quot;, &quot;age&quot;: 18}
dic.pop('name')
del dic['age']
print(dic) # {}
</code></pre>
<p>简述多线程、多进程</p>
<pre><code>进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。
线程是程序执行时的最小单位，它是进程的一个执行流。
进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵
线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多
</code></pre>
<p>简述 any() 和 all() 方法</p>
<pre><code># all如果存在0 Null False返回False,否则返回True;any与之相反
print(all([0, 1, 2, 3]))
print(all([1, 2, 3]))
</code></pre>
<p>IOError、AttributeError、ImportError、IndentationError、IndexError、KeyError、SyntaxError、NameError 分别代表什么异常</p>
<pre><code>    IOError：输入输出异常
    AttributeError：试图访问一个对象没有的属性
    ImportError：无法引入模块或包，基本是路径问题
    IndentationError：语法错误，代码没有正确的对齐
    IndexError：下标索引超出序列边界
    KeyError:试图访问你字典里不存在的键
    SyntaxError:Python代码逻辑语法出错，不能执行
    NameError:使用一个还未赋予对象的变量
</code></pre>
<p>Python 中 copy 和 deepcopy 区别</p>
<pre><code>    # copy
    l1 = [1, 2, [3, 4]]
    l2 = copy.copy(l1)
    l1.append(5)
    l1[2].append(5)  # 子对象 改变
    print(l1)
    print(l2)
    --------------
    [1, 2, [3, 4, 5], 5]
    [1, 2, [3, 4, 5]]
    # deepcopy
    l1 = [1, 2, [3, 4]]
    l2 = copy.deepcopy(l1)
    l1.append(5)
    l1[2].append(5)
    print(l1)
    print(l2)
    --------------
    [1, 2, [3, 4, 5], 5]
    [1, 2, [3, 4]]
</code></pre>
<p>列出几种魔法方法并简要介绍用途</p>
<pre><code>__init__:对象初始化方法
__new__:创建对象时候执行的方法，单列模式会用到
__str__:当使用print输出对象的时候，只要自己定义了__str__(self)方法，那么就会打印从在这个方法中return的数据
__del__:删除对象执行的方法
</code></pre>
<p>上下文管理器 with...as 的实现</p>
<pre><code>    class Close():
        def __init__(self, obj):
            self.obj = obj

        def __enter__(self):
            return self.obj  # 返回作为as目标

        def __exit__(self, exc_type, exc_val, exc_tb):
            try:
                self.obj.close()
            except AttributeError:
                print(exc_type)
</code></pre>
<p>python arg.py 1 2 命令行启动程序并传参，print(sys.argv) 会输出什么数据？</p>
<pre><code>['arg.py', '1', '2']
</code></pre>
<p>请将[i for i in range(3)]改成生成器</p>
<pre><code>    class iter():
        def __init__(self, data):
            self.data = data
            self.loop = -1
        def __iter__(self):
            return self
        def __next__(self):
            if self.loop &gt;= self.data:
                raise StopIteration
            self.loop += 1
            return self.loop
</code></pre>
<p>字符串转化大小写？</p>
<pre><code>str=&quot;HHaa&quot;
print(str.upper())
print(str.lower())
</code></pre>
<p>请说明 sort 和 sorted 对列表排序的区别</p>
<pre><code>1.sort()与sorted()的不同在于，sort是在原位重新排列列表，而sorted()是产生一个新的列表。sorted(L)返回一个排序后的L，不改变原始的L；L.sort()是对原始的L进行操作，调用后原始的L会改变，没有返回值；所以a = a.sort()是错的啦！a = sorted(a)才对。
2.sorted()适用于任何可迭代容器，list.sort()仅支持list（本身就是list的一个方法）
3.基于以上两点，sorted使用频率比list.sort()更高些，所以Python中更高级的排序技巧便通过sorted()来演示
</code></pre>
<p>对 foo = [-5,8,0,4,9,-4,-20,-2,8,2,-4] 进行排序，使用 lambda 函数从小到大排序</p>
<pre><code>foo = [-5,8,0,4,9,-4,-20,-2,8,2,-4]
res=sorted(foo,key=lambda x:x)      
print(res)
</code></pre>
<p>在 70 题的基础上将正数从小到大，负数从大到小</p>
<pre><code>foo = [-5,8,0,4,9,-4,-20,-2,8,2,-4]
res=sorted(foo,key=lambda x:(x&lt;0,abs(x)))    
print(res)
</code></pre>
<p>Python 传参数是传值还是传址？</p>
<blockquote>
<p>Python 中函数参数是引用传递（注意不是值传递）。对于不可变类型（数值型、字符串、元组），因变量不能修改，所以运算不会影响到变量自身；而对于可变类型（列表字典）来说，函数体运算可能会更改传入的参数变量。</p>
</blockquote>
<p>w、w+、r、r+、rb、rb+ 文件打开模式区别</p>
<figure data-type="image" tabindex="3"><img src="https://images.gitbook.cn/89fca880-4539-11e9-b7cd-b595562b2f4a" alt="enter image description here" loading="lazy"></figure>
<p>int(&quot;1.4&quot;)、int(1.4)的输出结果？</p>
<pre><code>print(int(&quot;1.4&quot;))   # 异常
print(int(1.4)) # 1
</code></pre>
<p>Python 垃圾回收机制？</p>
<pre><code>    1.引用计数
    import sys
    # 请在Python解释器下运行  为 2  创建一次 调用一次
    str1 = 'hello world'
    print(sys.getrefcount(str1))
    2.分代技术
    Python默认定义了三代对象集合，索引数越大，对象存活时间越长
    Python中使用了某些启发式算法（heuristics）来加速垃圾回收。例如，越晚创建的对象更有可能被回收。对象被创建之后，垃圾回收器会分配它们所属的代（generation）。每个对象都会被分配一个代，而被分配更年轻代的对象是优先被处理的。
    3.引用循环
    垃圾回收器会定时寻找这个循环，并将其回收。举个例子，假设有两个对象o1和o2，而且符合o1.x == o2和o2.x == o1这两个条件。如果o1和o2没有其他代码引
</code></pre>
<p>Python 字典和 json 字符串相互转化方法</p>
<pre><code>    import json
    dic = {&quot;name&quot;:&quot;zs&quot;}
    res = json.dumps(dic)
    print(res,type(res))
    ret = json.loads(res)
    print(ret,type(ret))
</code></pre>
<p>Python 正则中 search 和 match 的区别</p>
<blockquote>
<p>match() 从第一个字符开始找, 如果第一个字符就不匹配就返回 None, 不继续匹配. 用于判断字符串开头或整个字符串是否匹配,速度快。 search() 会整个字符串查找,直到找到一个匹配。</p>
</blockquote>
<p>Python 中读取 Excel 文件的方法？</p>
<pre><code>import pandas
read_excel = pandas.read_excel(&quot;test.xlsx&quot;)
print(read_excel)
</code></pre>
<p>输入日期， 判断这一天是这一年的第几天？</p>
<pre><code>import datetime
def dayofyear():
    year = input(&quot;请输入年份: &quot;)
    month = input(&quot;请输入月份: &quot;)
    day = input(&quot;请输入天: &quot;)
    date1 = datetime.date(year=int(year),month=int(month),day=int(day))
    date2 = datetime.date(year=int(year),month=1,day=1)
    return (date1-date2).days+1
</code></pre>
<p>什么是 lambda 函数？有什么好处？</p>
<pre><code>    lambda 函数是一个可以接收任意多个参数(包括可选参数)并且返回单个表达式值的匿名函数

    好处：
    1、lambda 函数比较轻便，即用即删除，很适合需要完成一项功能，但是此功能只在此一处使用，
    连名字都很随意的情况下；
    2、匿名函数，一般用来给 filter， map 这样的函数式编程服务;
    3、作为回调函数，传递给某些应用，比如消息处理
</code></pre>
<p>求两个列表的交集、差集、并集？</p>
<pre><code>    a= [1,2,3,4]
    b= [4,3,5,6]
    jj1=[i for i in a if i in b]   #在a中的i，并且也在b中，就是交集
    jj2=list(set(a).intersection(set(b)))
    bj1=list(set(a).union(set(b)))
    cj1=list(set(b).difference(set(a)))
    cj2=list(set(a).difference(set(b)))
    print(&quot;交集&quot; ,jj1)
    print(&quot;交集&quot;,jj2)
    print(&quot;并集&quot;,bj1)
    print(&quot;差集&quot; ,cj1)
    print(&quot;差集&quot; ,cj2)
</code></pre>
<p>什么是负索引？</p>
<pre><code>与正索引不同，负索引是从右边开始检索
</code></pre>
<p>正则匹配不是以4和7结尾的手机号？</p>
<pre><code>    import re
    tels=[&quot;13100001234&quot;,&quot;18912344321&quot;,&quot;10086&quot;,&quot;18800007777&quot;]
    for tel in tels:
        ret=re.match(&quot;1\d{9}[0-3,5-6,8-9]&quot;,tel)
        if ret:
            print(&quot;结果是：&quot;,ret.group())
        else:
            print(&quot;%s不是想要的手机号&quot; % tel)
</code></pre>
<p>用两种方法去空格？</p>
<pre><code>    str=&quot;hello world ha ha&quot;
    res=str.replace(&quot; &quot;,&quot;&quot;)
    print(res)

    list=str.split(&quot; &quot;)
    res=&quot;&quot;.join(list)
    print(res)

    均输出：
    helloworldhaha
</code></pre>
<p>统计字符串中某字符出现次数？</p>
<pre><code>str=&quot;张三 哈哈 张三 呵呵 张三&quot;
res=str.count(&quot;张三&quot;)
print(res) 
</code></pre>
<p>正则表达式匹配 URL</p>
<pre><code>    import re
    pattern = re.compile(r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&amp;+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+')    # 匹配模式

    string = 'Its after 12 noon, do you know where your rooftops are? https://blog.gaozhe.top '
    url = re.findall(pattern,string)
    print(url)
</code></pre>
<p>正则匹配以 163.com 结尾的邮箱？</p>
<pre><code>    import re
    email_list= [&quot;sdgaozhe@163.com&quot;,&quot;xiaoWang@163.comheihei&quot;, &quot;.com.602556194g@qq.com&quot; ]
    for email in email_list:
        ret = re.match(&quot;[\w]{4,20}@163\.com$&quot;,email)
        if ret:
            print(&quot;%s 是符合规定的邮件地址，匹配后结果是:%s&quot; % (email,ret.group()))
        else:
            print(&quot;%s 不符合要求&quot; % email)
</code></pre>
<p><code>s=&quot;info:xiaoZhang 33 shandong&quot;</code>,用正则切分字符串输出<code>['info', 'xiaoZhang', '33', 'shandong']</code></p>
<pre><code>    import re
    s=&quot;info:xiaoZhang 33 shandong&quot;
    res=re.split(r&quot;:| &quot;,s)          #|表示或，根据冒号或者空格切分
    print(res)
</code></pre>
<p>两个有序列表，l1,l2，对这两个列表进行合并不可使用 extend</p>
<pre><code>    def loop_merge_sort(l1,l2):
        tmp = []
        while len(l1)&gt;0 and len(l2)&gt;0:
            if l1[0] &lt;l2[0]:
                tmp.append(l1[0])
                del l1[0]
            else:
                tmp.append(l2[0])
                del l2[0]
</code></pre>
<p>代码描述列表推导式、字典推导式、生成器？</p>
<pre><code>    import random
    td_list=[i for i in range(10)]
    print(&quot;列表推导式&quot;, td_list, type(td_list))
    ge_list = (i for i in range(10))
    print(&quot;生成器&quot;, ge_list)
    dic = {k:random.randint(4, 9)for k in [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]}
    print(&quot;字典推导式&quot;,dic,type(dic))
</code></pre>
<p>根据键对字典排序，不可使用zip？</p>
<pre><code>    dic = {&quot;name&quot;:&quot;zs&quot;,&quot;sex&quot;:&quot;man&quot; ,&quot;city&quot;:&quot;bj&quot;}
    print(dic.items())
    b= sorted(dic.items(),key= lambda x:x[0])
    print(&quot;根据键排序&quot;,b)
    new_dic = {i[0]:i[1] for i in b}
    print(&quot;字典推导式构造新字典&quot;,new_dic)
</code></pre>
<p>阅读一下代码他们的输出结果是什么？</p>
<pre><code>def multi():
    return [lambda x : i*x for i in range(4)]
print([m(3) for m in multi()])  # [9,9,9,9]
</code></pre>
<p>代码实现 Python 的线程同步</p>
<pre><code>    import threading 
    import time

    def thread():
        time.sleep(2)
        print('---子线程结束---')

    def main():
        t1 = threading.Thread(target=thread)
        t1.start()
        print('---主线程--结束')

    if __name__ =='__main__':
        main()
    #执行结果
    ---主线程--结束
    ---子线程结束---
</code></pre>
<p>简述 read、readline、readlines 的区别？</p>
<pre><code>read 读取整个文件
readline 读取下一行,使用生成器方法
readlines 读取整个文件到一个迭代器以供我们遍历
</code></pre>
<p>a = &quot; hehheh &quot;，去除收尾空格？</p>
<pre><code>a=&quot;  hehheh  &quot;
print(a.strip())
</code></pre>
<p>yield 用法</p>
<pre><code>yield 就是保存当前程序执行状态。你用 for 循环的时候，每次取一个元素的时候就会计算一次。用 yield 的函数叫 generator,和 iterator 一样，它的好处是不用一次计算所有元素，而是用一次算一次，可以节省很多空间，generator 每次计算需要上一次计算结果，所以用 yield,否则一 return，上次计算结果就没了。
</code></pre>
<p>字符串 &quot;123&quot; 转换成 123，不使用内置 API，例如 int()</p>
<pre><code>    def atoi(s):
        num = 0
        for v in s:
            t = &quot;%s * 1&quot; % v
            n = eval(t)
            num = num * 10 + n
        return num
</code></pre>
<p>is 和 == 的区别</p>
<pre><code>    # is 比较的是内存地址   == 比较内容和数据类型

    a = [1, 2, 3]
    b = a
    print(a is b)
    print(a == b)

    c = copy.deepcopy(a)
    print(a is c)
    print(a == c)
    -------------
    True
    True
    False
    True
</code></pre>
<p>有没有一个工具可以帮助查找 python 的 bug 和进行静态的代码分析？</p>
<blockquote>
<p>PyChecker 是一个 python 代码的静态分析工具，它可以帮助查找 python 代码的 bug，会对代码的复杂度和格式提出警告 Pylint 是另外一个工具可以进行 codingstandard 检查</p>
</blockquote>
<p>文件递归</p>
<pre><code>    def print_directory_contents(sPath):
    &quot;&quot;&quot;
    这个函数接收文件夹的名称作为输入参数
    返回该文件夹中文件的路径
    以及其包含文件夹中文件的路径
    &quot;&quot;&quot;
    import os
    for s_child in os.listdir(s_path):
        s_child_path = os.path.join(s_path, s_child)
        if os.path.isdir(s_child_path):
            print_directory_contents(s_child_path)
        else:
            print(s_child_path)
</code></pre>
<p>Python 如何 copy 一个文件？</p>
<blockquote>
<p>shutil 模块有一个 copyfile 函数可以实现文件拷贝</p>
</blockquote>
<p>打乱一个排好序的 list 对象 alist？</p>
<pre><code>    import random
    alist = [1,2,3,4,5]
    random.shuffle(alist)
    print(alist)
</code></pre>
<p>对 s=&quot;hello&quot;进行反转</p>
<pre><code>s=&quot;hello&quot;
print(s[::-1])
</code></pre>
<p>Python 中单下划线和双下划线使用</p>
<pre><code>__foo__:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突，就是例如__init__(),__del__(),__call__()这些特殊方法

_foo:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.不能用from module import * 导入，其他方面和公有一样访问；

__foo:这个有真正的意义:解析器用_classname__foo来代替这个名字,以区别和其他类相同的命名,它无法直接像公有成员一样随便访问,通过对象名._类名__xxx这样的方式可以访问.
</code></pre>
<p>反转一个整数</p>
<pre><code>    class Solution(object):
        def reverse(self,x):
            if -10&lt;x&lt;10:
                return x
            str_x = str(x)
            if str_x[0] !=&quot;-&quot;:
                str_x = str_x[::-1]
                x = int(str_x)
            else:
                str_x = str_x[1:][::-1]
                x = int(str_x)
                x = -x
            return x if -2147483648&lt;x&lt;2147483647 else 0
    if __name__ == '__main__':
        s = Solution()
        reverse_int = s.reverse(-120)
        print(reverse_int)
</code></pre>
<p>代码描述静态方法 (staticmethod)，类方法(classmethod) 和实例方法</p>
<pre><code>    def foo(x):
        print &quot;executing foo(%s)&quot;%(x)

    class A(object):
        def foo(self,x):
            print &quot;executing foo(%s,%s)&quot;%(self,x)

        @classmethod
        def class_foo(cls,x):
            print &quot;executing class_foo(%s,%s)&quot;%(cls,x)

        @staticmethod
        def static_foo(x):
            print &quot;executing static_foo(%s)&quot;%x

    a=A()
</code></pre>
<p>新式类和旧式类的区别？</p>
<pre><code>a. 在python里凡是继承了object的类，都是新式类
b. Python3里只有新式类
c. Python2里面继承object的是新式类，没有写父类的是经典类
d. 经典类目前在Python里基本没有应用
</code></pre>
<p>请写出一个在函数执行后输出日志的装饰器</p>
<pre><code>    def do_log(func):
        @wraps(func)
        def wrapper(*args, **kw):
            if func.__name__ == &quot;debug&quot;:
                msg = &quot;debug {}&quot;.format(args[0])
            elif func.__name__ == &quot;info&quot;:
                msg = &quot;info {}&quot;.format(args[0])
            else:
                msg =  &quot;unknown {}&quot;.format(args[0])
            return func(msg, **kw)
        return wrapper

    @do_log
    def debug(msg):
        print(msg)

    @do_log
    def info(msg):
        print(msg)

    if __name__ == &quot;__main__&quot;:
        debug(&quot;123&quot;)
        info(&quot;abc&quot;)
</code></pre>
<p>请解释一下协程的优点</p>
<pre><code>子程序切换不是线程切换，而是由程序自身控制
没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显
不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁
</code></pre>
<p>闭包必须满足那几点</p>
<pre><code>1.必须有一个内嵌函数
2.内嵌函数必须引用外部函数中的变量
3.外部函数的返回值必须是内嵌函数
</code></pre>
<h3 id="简历制作与面试技巧">简历制作与面试技巧</h3>
<h4 id="简历中的常见错误">简历中的常见错误</h4>
<p>信息过多，缺乏重点</p>
<figure data-type="image" tabindex="4"><img src="https://images.gitbook.cn/dfac3910-45f9-11e9-9c92-3786ebe58132" alt="enter image description here" loading="lazy"></figure>
<p>无意义的描述</p>
<blockquote>
<p>XXX 平台 根据项目任务要求完成爬虫模块，前端展示模块，完成数据整理与入库功能。</p>
<p>XXX 平台 构建 IP 代理池，使用 Scrapy 开发异步爬虫系统，优化爬虫策略和防屏蔽规则，提升 200% 网页抓取速度。 使用 Vue 框架完成后台管理系统，实现自定义分页，第三方登录等 6个 主要功能。 负责数据的清洗与存储到 MySQL 数据库，使用数据库索引减少 50% 数据查询时间。</p>
</blockquote>
<p>排版杂乱，错别字多</p>
<figure data-type="image" tabindex="5"><img src="https://images.gitbook.cn/6df19440-45fa-11e9-9afd-9710eb3acd93" alt="enter image description here" loading="lazy"></figure>
<h4 id="如何写一份更好的简历">如何写一份更好的简历</h4>
<figure data-type="image" tabindex="6"><img src="https://images.gitbook.cn/038a8bb0-45fb-11e9-b237-6f62ccae6012" alt="enter image description here" loading="lazy"></figure>
<h4 id="综合起来">综合起来</h4>
<figure data-type="image" tabindex="7"><img src="https://images.gitbook.cn/a55ff2a0-45fa-11e9-b237-6f62ccae6012" alt="enter image description here" loading="lazy"></figure>
<h3 id="面试技巧">面试技巧</h3>
<h4 id="好的自我介绍决定了面试的-80">好的自我介绍决定了面试的 80%</h4>
<p>不管你相不相信，你适不适合这份工作，HR 在你自我介绍的阶段，已经基本决定了。很多人在自我介绍时会犯一个错误，那就是把自己的学校情况，工作经历，兴趣爱好笼统的丢给 HR，让他自己判断你适不适合这份工作。如果你这么做了，恭喜你，你已经进入了 HR 心中的“平庸组”名单。那么，自我介绍到底应该说些什么呢？你应该斩钉截铁地告诉他：为什么这份工作非要你来做才适合！所以，每一次面试我都会告诉面试官：“我看到在招聘启事上，这份工作需要 blabla，这和我之前的工作经历中 blabla 非常类似。”</p>
<h4 id="你对我们公司了解多少">你对我们公司了解多少？</h4>
<p>这是让很多面试者头疼的一个问题，难点就在于，大家说的都差不多，你很难在众多面试者中脱颖而出。如果你按照某度的搜索结果，只是说出这家公司的行业地位，规模，企业文化等，那这个问题就算是白问了。因为，面试官其实想问的是：为什么你非得选择我们公司？我下面要说的就是：如何通过半小时的准备，给面试官留下一个难以磨灭的印象。</p>
<p>这个方法叫做：概况+细节+情绪。概况不要多说，因为这点并不决定你和其他面试者的差异。你只要说出公司的地位、总部、规模等信息即可。接下来，你就要开始说细节了，这很重要！非常简单但给人印象很深的做法是，你看几个该企业的宣传片，然后用绘声绘色、深受感染的语气描绘其中的情节，比如：“我感触特别深的就是贵公司的数据审核产品，他极大了解决了人工审核慢而且容易出错的问题，具有很好的商业前景”。这样做有什么好处？就是能在最短的时间内，调动起面试官的全部情绪。注意到其中好玩的地方了吗？面试官的情绪越高涨，对面试者留下的印象也就越深。</p>
<h4 id="离职原因处处是陷阱">离职原因——处处是陷阱</h4>
<p>离职原因是一个很重要的问题，因为它考验的不但是你的工作能力和性格，更考验你的情商和智商。不讨巧的离职原因包括：工作业绩差，沟通能力差，老板傻逼，看同事不顺眼，和公司有纠纷……所以，尽量挑一些主观上无法避免的原因，比如：公司的产品质量出了问题，公司面临破产，部门被合并，亲人有重大变故，公司的氛围和你想要的相去甚远（顺便夸夸新东家）。最重要的一点是，强调现在是你最想要稳定的时期。换句话说，就是前面那些都是浮云！</p>
<h4 id="你的缺点是什么">你的缺点是什么？</h4>
<p>缺点真的是一个非常不好答的问题，但是只要掌握了以下这个原则，这道问题也只是小菜一碟，那就是：避重就轻。什么是重？性格方面的问题，人际方面的问题，工作能力方面的原因。如果你说：“我的缺点就是耐心太差”，“我的缺点就是沟通能力有待提高”，那你真的是一个大傻帽。什么是轻？举点例子：我方向感不太好，不善于理财（金融岗位除外）之类的。有人会问了，我说了这些缺点，面试官会不会觉得我很虚伪？那我告诉你，只要你的虚伪不至于让他想吐（比如“我最大的缺点就是太追求完美”），那虚伪绝对要比傻乎乎的坦诚好。</p>
<h4 id="你有什么想问我的吗">你有什么想问我的吗？</h4>
<p>一般问到这个问题，整个面试就要结束了，但是不要掉以轻心，因为最后这个问题决定了面试官对你的最终印象。</p>
<p>所以这个问题背后的潜台词是什么呢？那就是：你还想了解一些什么，帮助你更好地留在这个公司？换言之，就是你有多想留在这个公司？ 如果你说“没有”，那么面试官说不定心里咯噔一下：原来你对这个职位兴趣也就这点啊……这个问题其实给了你表忠心的机会，你可以很认真地问她：“那如果我来到了这个公司，那每天的日常大概会是什么样的？”或者“这个公司的氛围是什么样的？”（暗示你来这里工作的强烈欲望）。</p>
<h3 id="总结">总结</h3>
<p>好了，面试攻略就分享到这里，最后送给大家一句话：找工作就是，胆大心细脸皮厚！如果你觉得这篇免费 Chat 对你有帮助，那就转发一下吧！</p>
<p>给大家介绍一下Mr. Chang的学习方法。学习的三种阶段：入门、掌握、精通。</p>
<ul>
<li>入门篇 -- 读文章 对这个知识有一定的了解，了解大概的发展趋势以及使用复杂程- 度，达到基本可以使用程度。</li>
<li>掌握篇 -- 看网上的教程 对这个知识使用并了解一些出现bug解决方案，扩展使用途径。</li>
<li>精通篇 -- 对知识体系结构已有完整认知 需要读别人写的书 加上自己亲自打代码时间 完全了解这个知识发展渊源。</li>
</ul>
<p>不论你是科班毕业还是非科班毕业，但要相信努力一定有收获，不要抱怨，趁年轻，多学习，你一定会成为 ta 心目中的哪个大英雄！</p>
<p>送给所有有梦想的我们一句话 ：相信自己，力量在心中！！</p>

      </div>
      <div class="entry-block">
        <div class="entry-tags">
          
            <a href="https://xiong-zh.github.io/NkK7F-WfX/">
              面试
            </a>
          
        </div>
      </div>
    </article>
    
      <section class="post-section prev-post">
        <div class="inner">
          <h3>前一篇</h3>
          <a href="https://xiong-zh.github.io/python-chang-jian-de-170-dao-mian-shi-ti-quan-jie-xi-2019-ban/">
            <strong>Python面试题全解析2019 版</strong>
          </a>
        </div>
      </section>
    
    
      <section class="post-section prev-post">
        <div class="inner">
          <h3>后一篇</h3>
          <a href="https://xiong-zh.github.io/flask_sqlalchemy/">
            <strong>Flask_SQLALchemy</strong>
          </a>
        </div>
      </section>
    

    
      
        <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '7691fdf5a3780e9bb3a4',
    clientSecret: 'f4bd6c2287489e6b24a18af94afd54efcd0f55f9',
    repo: 'xiong-zh.github.io',
    owner: 'xiong-zh',
    admin: ['xiong-zh'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

      

      
    

    <footer class="footer">
  <div class="main">
    <a href="https://xiong-zh.github.io">
      <img class="avatar" src="https://xiong-zh.github.io/images/avatar.png?v=1582985743430" alt="ZhangXiong">
    </a>
    <div class="footer__social">
      
        
          <a href="https://github.com/xiong-zh" target="_blank"><i class="remixicon-github-line"></i></a>
        
      
        
          <a href="https://twitter.com/imzhangxiong" target="_blank"><i class="remixicon-twitter-line"></i></a>
        
      
        
          <a href="https://weibo.com/zhangxiongblog" target="_blank"><i class="remixicon-weibo-line"></i></a>
        
      
        
          <a href="https://www.zhihu.com/people/yisyxi" target="_blank"><i class="remixicon-zhihu-line"></i></a>
        
      
        
          <a href="https://www.facebook.com/xiong.zh.397" target="_blank"><i class="remixicon-facebook-line"></i></a>
        
      
        
      
        
      
        
          <a href="https://www.instagram.com/imzhangxiong/" target="_blank"><i class="remixicon-instagram-line"></i></a>
        
      
        
      
        
      
    </div>
    <p class="footer__sosumi">
      <a href="http://beian.miit.gov.cn/" target="_blank">滇ICP备20001109号</a> | Copyright © 2020 <a href="https://zhangxiong.net/" target="_blank">｜zhangxiong </a> All Right Reserved.
    </p>
    <a class="footer-rss" href="https://xiong-zh.github.io/atom.xml">RSS</a>
  </div>
</footer>

<script src="https://xiong-zh.github.io/media/prism.js"></script>
<script>
  Prism.highlightAll()
</script>

  </body>
</html>
