<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ZhangXiong</title>
<meta name="description" content="凡心所向,素履所往。生如逆旅，一苇以航。" />
<link rel="shortcut icon" href="https://xiong-zh.github.io/favicon.ico?v=1580565597732">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.remixicon.com/releases/v1.3.1/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://xiong-zh.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="ZhangXiong - Atom Feed" href="https://xiong-zh.github.io/atom.xml">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-156420077-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-156420077-1');
</script>


  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="remixicon-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://xiong-zh.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://xiong-zh.github.io/images/avatar.png?v=1580565597732" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">ZhangXiong</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>
<ul>
<li><a href="#%E6%95%B0%E5%AD%97num">数字（num）</a></li>
<li><a href="#%E5%B8%83%E5%B0%94bool%E4%B8%8E%E9%80%BB%E8%BE%91">布尔（bool）与逻辑</a></li>
<li><a href="#%E5%BA%8F%E5%88%97sequence">序列（sequence）</a>
<ul>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2str">字符串（str）</a></li>
<li><a href="#%E5%88%97%E8%A1%A8list">列表（list）</a></li>
<li><a href="#%E5%85%83%E7%BB%84tuple">元组（tuple）</a></li>
</ul>
</li>
<li><a href="#%E5%AD%97%E5%85%B8dict">字典（dict）</a></li>
<li><a href="#%E9%9B%86%E5%90%88set">集合（set）</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5">基本语句</a>
<ul>
<li><a href="#if-%E8%AF%AD%E5%8F%A5%E4%B8%8E%E4%B8%89%E5%85%83%E6%93%8D%E4%BD%9C">if 语句与三元操作</a></li>
<li><a href="#for-%E8%AF%AD%E5%8F%A5">for 语句</a></li>
<li><a href="#while-%E8%AF%AD%E5%8F%A5">while 语句</a></li>
<li><a href="#%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90">列表解析</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%A4%E6%96%AD">函数定义与判断</a></li>
<li><a href="#%E4%B8%8D%E5%AE%9A%E5%8F%82%E5%87%BD%E6%95%B0">不定参函数</a></li>
<li><a href="#zip-%E5%87%BD%E6%95%B0">zip 函数</a></li>
<li><a href="#lambda-%E5%87%BD%E6%95%B0">lambda 函数</a></li>
<li><a href="#map-%E5%87%BD%E6%95%B0">map 函数</a></li>
<li><a href="#filter-%E5%87%BD%E6%95%B0">filter 函数</a></li>
<li><a href="#reduce-%E5%87%BD%E6%95%B0">reduce 函数</a></li>
<li><a href="#enumerate-%E5%87%BD%E6%95%B0">enumerate 函数</a></li>
</ul>
</li>
<li><a href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%AE%97%E5%AD%90">装饰器：算子</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-itertools">迭代器 [itertools]</a>
<ul>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a></li>
<li><a href="#%E7%94%9F%E6%88%90%E5%99%A8">生成器</a></li>
</ul>
</li>
<li><a href="#%E9%94%99%E8%AF%AFtry-%E8%AF%AD%E5%8F%A5">错误：<code>try()</code> 语句</a>
<ul>
<li><a href="#%E5%A4%9A%E4%B8%AA-except-%E5%9D%97">多个 except 块</a></li>
<li><a href="#%E9%94%99%E8%AF%AF%E7%9A%84%E6%8D%95%E8%8E%B7">错误的捕获</a></li>
<li><a href="#%E9%94%99%E8%AF%AF%E7%9A%84%E6%8A%9B%E5%87%BA%E5%8F%8A%E4%B8%8A%E6%8A%9B">错误的抛出及上抛</a></li>
</ul>
</li>
<li><a href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99">文件读写</a>
<ul>
<li><a href="#%E4%B8%80%E8%88%AC%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9Cread-readlines">一般读写操作：<code>read() / readlines()</code></a></li>
<li><a href="#%E5%A4%A7%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96readline">大文件读取：<code>readline()</code></a></li>
</ul>
</li>
<li><a href="#%E7%B1%BB">类</a>
<ul>
<li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0__init__">构造函数：<code>__init__()</code></a></li>
<li><a href="#%E5%B0%81%E8%A3%85">封装</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF">继承</a></li>
<li><a href="#property-%E8%A3%85%E9%A5%B0%E5%99%A8">@property 装饰器</a></li>
<li><a href="#%E7%B1%BB%E7%9A%84%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95">类的特殊属性与方法</a>
<ul>
<li><a href="#%E5%B1%9E%E6%80%A7-__dict__">属性 <code>__dict__</code></a></li>
<li><a href="#%E5%B1%9E%E6%80%A7-__slots__">属性 <code>__slots__</code></a></li>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">运算符重载</a></li>
</ul>
</li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E8%A1%8C%E4%B8%BA">迭代行为</a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97">常用模块</a>
<ul>
<li><a href="#os-%E6%A8%A1%E5%9D%97">os 模块</a></li>
<li><a href="#sys-%E6%A8%A1%E5%9D%97">sys 模块</a></li>
<li><a href="#re-%E6%A8%A1%E5%9D%97%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">re 模块：正则表达式</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E6%A8%A1%E5%9D%97">其他模块</a></li>
</ul>
</li>
<li><a href="#%E8%B0%83%E8%AF%95%E4%B8%8E%E6%B5%8B%E8%AF%95">调试与测试</a>
<ul>
<li><a href="#%E6%96%AD%E8%A8%80assert">断言：assert</a></li>
<li><a href="#%E6%97%A5%E5%BF%97%E8%B0%83%E8%AF%95logging-%E6%A8%A1%E5%9D%97">日志调试：logging 模块</a></li>
</ul>
</li>
<li><a href="#%E9%99%84%E5%BD%95%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">附录：正则表达式</a></li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="remixicon-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          回到首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          历史归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          所有标签
        </a>
      
    
      
        <a href="/documents/" class="menu" style="animation-delay: 0.6000000000000001s" target="_blank">
          后端图谱
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.8s">
          关于｜友链
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> Copyright © 2020 <a href="https://zhangxiong.net/" target="_blank">zhangxiong</a> 版权所有</div>
    <a class="rss" href="https://xiong-zh.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">Python语法速查</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2020-01-18 / 41 min read
        </div>
        
          <img class="post-feature-image rounded-lg mx-auto my-4" src="http://zhangxiong-blog-pic.test.upcdn.net/blog/img/f18.jpg" alt="">
        
        <div class="post-content yue">
          <p>Python 是一门独特的语言，快速浏览一下他的要点：</p>
<ul>
<li>面向对象：每一个变量都是一个类，有其自己的属性（attribute）与方法（method）。</li>
<li>语法块：用缩进（四个空格）而不是分号、花括号等符号来标记。因此，行首的空格不能随意书写。</li>
<li>注释：行内用“#”号，行间注释写在两组连续三单引号之间：’’’</li>
<li>续行：行尾输入一个反斜杠加一个空格（’\ ‘），再换行。如果行尾语法明显未完成（比如以逗号结尾），可以直接续行。</li>
<li>打印与输入： 函数 print() 与 input()，注意 print() 的 sep 与 end 参数。</li>
</ul>
<!--more-->
<h1 id="介绍">介绍</h1>
<p>Python 是一门独特的语言，快速浏览一下他的要点：</p>
<ul>
<li>面向对象：每一个变量都是一个类，有其自己的属性（attribute）与方法（method）。</li>
<li>语法块：用缩进（四个空格）而不是分号、花括号等符号来标记。因此，行首的空格不能随意书写。</li>
<li>注释：行内用“#”号，行间注释写在两组连续三单引号之间：’’’</li>
<li>续行：行尾输入一个反斜杠加一个空格（’\ ‘），再换行。如果行尾语法明显未完成（比如以逗号结尾），可以直接续行。</li>
<li>打印与输入： 函数 print() 与 input()，注意 print() 的 sep 与 end 参数。</li>
<li>变量：无需指定变量类型，也不需要提前声明变量。
<ul>
<li>删除变量：del()</li>
<li>复制变量：直接将变量a赋值给b，有时仅仅复制了一个“引用”。此后 b 与 a 的改动仍会互相影响。必要时使用 a is b 来判断是否同址。</li>
</ul>
</li>
<li>模块：通过 import pandas 的方式加载模块（或者 import pandas as pd），并用形如 pandas.DataFrame（或 pd.DataFrame）的方式调用模块内的方法。也可以使用 from pandas import DataFrame 的方式，这样在下文可以直接使用 DataFrame 作为调用名。</li>
<li>帮助：配合使用 dir() 与 help() 命令；其中前者是输出变量所有的成员。以及查阅 官网页面。</li>
</ul>
<p>变量复制的一个例子。</p>
<pre><code>a = [1, 2]
b = a
print(id(a) - id(b))  # 地址差为 0，表示实质是同址的
0
</code></pre>
<pre><code>b.append(3)
print(a)  # 只改动了 b，但 a 也跟着变动了
[1, 2, 3]
a is b
True
</code></pre>
<p>使用切片来重新分配空间：</p>
<pre><code>a is a[:]
False
</code></pre>
<h1 id="数据结构">数据结构</h1>
<p>Python 原生的数据结构包括：</p>
<h2 id="数字num">数字（num）</h2>
<p>细分为整数（int）与浮点数（float）两种。</p>
<ul>
<li>四则运算：+， -， *， / ，乘方： **</li>
<li>整除： 5 // 2 = 2，取余：5 % 2 = 1</li>
<li>自运算： a += 1 （四则与乘方均可类似自运算）<br>
以及一些细节：</li>
<li>运算两数中只要有一个浮点数，结果就是浮点数；</li>
<li>整数相除，即使能除尽，结果也是浮点数；</li>
<li>Python 内部的机制解决了整数溢出的问题，不用担心。</li>
</ul>
<h2 id="布尔bool与逻辑">布尔（bool）与逻辑</h2>
<p>首字母大写 True / False.</p>
<ul>
<li>逻辑运算符：与 A and B，或 A or B，非 not A</li>
<li>逻辑关系符：等于 ==， 不等于 !=. 其他不赘述。</li>
<li>几种逻辑判断例子：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">变量 x</th>
<th style="text-align:center">x = []</th>
<th style="text-align:center">x = 0</th>
<th style="text-align:center">x = 2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bool(x)</td>
<td style="text-align:center">False</td>
<td style="text-align:center">False</td>
<td style="text-align:center">True</td>
</tr>
<tr>
<td style="text-align:center">if x: …</td>
<td style="text-align:center">False</td>
<td style="text-align:center">False</td>
<td style="text-align:center">True</td>
</tr>
<tr>
<td style="text-align:center">if x is None: …</td>
<td style="text-align:center">False</td>
<td style="text-align:center">False</td>
<td style="text-align:center">False</td>
</tr>
</tbody>
</table>
<h2 id="序列sequence">序列（sequence）</h2>
<p>序列主要包括**字符串（str）、列表（list）与元祖（tuple）**三类。</p>
<ul>
<li>序列索引规则：
<ul>
<li>索引从0开始，到 N-1 结束。</li>
<li>切片：切片的索引是左闭右开的。
<ul>
<li>seq[0:2]（从 0 到 1）</li>
<li>seq[2:]（从 2 到尾）</li>
<li>seq[:3] （从头到 2）</li>
<li>seq[:]（全部）</li>
<li>seq[:10:2]（从头到9，每两个取一个）</li>
<li>seq[::2]（全部，每两个取一个）</li>
</ul>
</li>
<li>索引允许负数：seq(-1) 与 seq(N - 1) 等同，seq(-3:-1)与 seq(N-3:N-1) 等同。</li>
</ul>
</li>
<li>序列通用函数：
<ul>
<li>len()：返回序列长度。</li>
<li>+/* ：加号用于连接两个序列，乘号重复排列若干次再连接。</li>
<li>seq1 in seq2：如果 seq1 这个片段可以在 seq2 中被找到，返回 True.</li>
<li>index：在 seq1 in seq2 为 True 时使用，seq2.index(seq1) 表示 seq1 首次出现于 seq2 中的位置。</li>
<li>max()/min()：返回序列中的最值。如果不是数字，则按 ASCII 码顺序返回。</li>
<li>cmp(seq1, seq2)：比较大小。结果为负，则表示 seq1 较小。</li>
</ul>
</li>
</ul>
<h3 id="字符串str">字符串（str）</h3>
<p>写于一对双引号或单引号内。用 str() 可以强制转换为字符串。</p>
<ul>
<li>
<p>转义：反斜杠。如果强制不解释字符串，在左引号前加字母 r 即可： <code>r&quot;c:\new&quot;</code>.</p>
</li>
<li>
<p>分割与连接：<code>**.split()</code> 与 <code>**.join()</code>.</p>
<pre><code>s = &quot; I love Python&quot;  # 首位是空格
lst = s.split(' ')
lst1 = '-'.join(lst)

print(lst, '\n', lst1)
['', 'I', 'love', 'Python'] 
 -I-love-Python
</code></pre>
</li>
<li>
<p>紧切：<code>strip()</code> 去掉字符串首尾两端的空格。方法 <code>lstrip()/rstrip()</code> 则只切除首端/尾端的空格。</p>
<pre><code>s.strip()
'I love Python'
</code></pre>
</li>
<li>
<p>大小写转换：如下几个方法：</p>
<ul>
<li>首字母大写：s.title()</li>
<li>全大写：s.upper()</li>
<li>全小写：s.lower()</li>
<li>句首大写：s.capitalize()</li>
</ul>
</li>
<li>
<p>格式化：字符串格式化是一种实用功能。通过 .format() 成员函数完成。</p>
<pre><code>'I like {} and {}'.format('Python', 'you')
'I like Python and you'
'{0} + {2} = {1}'.format (10, 20, 'Python ')  # 按顺序引用
'10 + Python  = 20'
'{0} * {1} = {0}'.format (10, 'Python ')  # 编号反复引用
'10 * Python  = 10'
</code></pre>
</li>
</ul>
<p>格式化控制码：</p>
<table>
<thead>
<tr>
<th style="text-align:center">控制码</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">控制码</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">😒</td>
<td style="text-align:center">字符串</td>
<td style="text-align:center">:c</td>
<td style="text-align:center">单个字符</td>
</tr>
<tr>
<td style="text-align:center">:b/o/x/d</td>
<td style="text-align:center">二、八、十六、十进制数</td>
<td style="text-align:center">:e/f</td>
<td style="text-align:center">科学计数法/浮点数</td>
</tr>
</tbody>
</table>
<p>一些复杂控制的例子：</p>
<table>
<thead>
<tr>
<th style="text-align:center">例子</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">例子</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">:.2f/:+.2f</td>
<td style="text-align:center">两位小数/带符号两位小数</td>
<td style="text-align:center">: .2f</td>
<td style="text-align:center">正数前补空格的两位小数</td>
</tr>
<tr>
<td style="text-align:center">:,</td>
<td style="text-align:center">逗号分隔符</td>
<td style="text-align:center">:.2%</td>
<td style="text-align:center">百分比两位小数</td>
</tr>
<tr>
<td style="text-align:center">:.2e</td>
<td style="text-align:center">科学计数法两位小数</td>
<td style="text-align:center">:^4d</td>
<td style="text-align:center">总宽四位居中对齐</td>
</tr>
<tr>
<td style="text-align:center">:&gt;4d/&lt;4d</td>
<td style="text-align:center">总宽四位左/右对齐</td>
<td style="text-align:center">:0&gt;4d</td>
<td style="text-align:center">总宽四位左侧补零</td>
</tr>
</tbody>
</table>
<p>举例：</p>
<pre><code>&quot;{:0&gt;7.2f} is an odd number&quot;.format(123.4)  # 总宽 7 位小数点后 2 位，左侧补零
'0123.40 is an odd number'
</code></pre>
<p>其他实用的字符串函数：</p>
<ul>
<li>str.replace(old, new[, times])：将字符串中前 times 个 old 子串替换为 new。Times 不指定时默认替换全部。</li>
<li>str.isdigit()：判断字符串是否每一位都是数字，返回 True 或者 False。<br>
字符串中正则表达式的内容参见本文附录。</li>
</ul>
<h3 id="列表list">列表（list）</h3>
<p>中括号式的结构。<code>list()</code> 用于强制转换类型。</p>
<pre><code>lst = [1, 2, 3]
print(lst)
[1, 2, 3]
# 【反转】：其中第二种方式会更改现有的列表
lst1 = list(reversed(lst))
lst.reverse()
print(lst1, lst)
[3, 2, 1] [3, 2, 1]
# 【追加】：元素 append()，另一个列表：extend()
lst.append(4)
print(lst)
[3, 2, 1, 4]
lst.extend(lst1)
print(lst)
[3, 2, 1, 4, 3, 2, 1]
# 【插入】：lst.insert(idx, obj) 会在 lst[idx] 处插入 obj，然后依次后移原有项
lst.insert(1, 100)
print(lst)
[3, 100, 2, 1, 4, 3, 2, 1]
# 【删除】：lst.remove(obj) 会删除首个匹配值，若无匹配会报错；
#           lst.pop(idx) 会返回 lst[idx]，并将其删除。如果不指定 idx，默认为列表尾
lst.remove(2)
print(lst)
[3, 100, 1, 4, 3, 2, 1]
tmp = lst.pop()
print(lst, &quot;\n&quot;, tmp)
[3, 100, 1, 4, 3, 2] 
 1
# 【搜索】：使用序列通用函数即可。用 count(obj) 可以计算频数。
# 【排序】：sort() 方法。如果指定 reverse 参数，可降序排序。
lst.sort(reverse=True)
print(lst)
[100, 4, 3, 3, 2, 1]
# 【清空】：clear()
lst.clear()
print(lst)
[]
</code></pre>
<h3 id="元组tuple">元组（tuple）</h3>
<p>圆括号式的结构，是一种不可变序列。</p>
<pre><code>a = (1, 'string ', [1 ,2])
print(a)
(1, 'string ', [1, 2])
</code></pre>
<p><strong>Note</strong>: 定义一个空的元组用<code>()</code>，定义只有一个元组的元组，需要加<code>,</code>，否则就不是元组了，如下：</p>
<pre><code>&gt;&gt;&gt; tuple1 = ()
&gt;&gt;&gt; type(tuple1)
&lt;type 'tuple'&gt;
&gt;&gt;&gt; tuple2 = (1)
&gt;&gt;&gt; type(tuple2)
&lt;type 'int'&gt;
&gt;&gt;&gt; tuple3 = (1,)
&gt;&gt;&gt; type(tuple3)
&lt;type 'tuple'&gt;
</code></pre>
<h2 id="字典dict">字典（dict）</h2>
<p>字典是一种类哈希表的数据结构，内部无序，通过键值对（key: value）的形式存储数据。几种字典初始化的方式：</p>
<pre><code># 小字典直接赋值
d1 = {&quot;name&quot;: &quot;wklchris&quot;, &quot;gender&quot;: &quot;male&quot;}
# 利用字典增加键值对的方法
d2 = {}
d2['name'] = 'wklchris'
# 一个值赋给多个键
d3 = {}.fromkeys((&quot;name&quot;, &quot;gender&quot;), &quot;NA&quot;)
# 强制格式转换
d4 = dict(name=&quot;wklchris&quot;, gender=&quot;male&quot;)

print(d1, d2, d3, d4, sep=&quot;\n&quot;)
{'name': 'wklchris', 'gender': 'male'}
{'name': 'wklchris'}
{'name': 'NA', 'gender': 'NA'}
{'name': 'wklchris', 'gender': 'male'}
</code></pre>
<p>字典的操作方法：</p>
<pre><code>len(d1)
2
# 【复制】：
dd = d1.copy()
dd is d1
False
# 【查找键名称】：
&quot;name&quot; in dd
True
# 【删除键值对】
del(dd[&quot;name&quot;])
# 【get】
dd.get(&quot;name&quot;, &quot;Nothing&quot;)  # 如果键不存在，返回“Nothing”
'Nothing'
# 【setdefault】
dd.setdefault(&quot;name&quot;, &quot;wklchris&quot;)  # 如果键不存在，就新建该键，并赋值
'wklchris'
print(dd)
{'name': 'wklchris', 'gender': 'male'}
# 【输出键值】：
list(dd.items())
[('name', 'wklchris'), ('gender', 'male')]
list(dd.keys())
['name', 'gender']
list(dd.values())
['wklchris', 'male']
# 【弹出键值对】：pop(key) / popitem(key)
# 其中，后者会随机弹出一个键值对
tmp = dd.pop(&quot;gender&quot;)
print(dd, tmp)
{'name': 'wklchris'} male
# 【更新】：update(ref_dict) 以 ref_dict 为准，更新当前字典
d4 = {&quot;name&quot;: &quot;Test&quot;, &quot;Age&quot;: 3}
dd.update(d4)
print(dd)
{'name': 'Test', 'Age': 3}
</code></pre>
<h2 id="集合set">集合（set）</h2>
<p>本文只讨论可变集合，关于不可变集合的内容，参考 help(frozenset)。</p>
<p>集合是一种无序的数据存储方式，且内部元素具有唯一性。集合与字典一样都可以用花括号的形式创立。但在书写 a={} 时，Python 会将其识别为字典类型。</p>
<ul>
<li>
<p>增添：add() / update()</p>
</li>
<li>
<p>删除：remove() / discard()，区别在于后者搜索无结果会报错。</p>
</li>
<li>
<p>从属：a.issubset(b) 集合 a 是否是 b 的子集；a.issuperset(b) 集合 a 是否是 b 的父集。a == b 两集合是否全等。</p>
</li>
<li>
<p>集合运算：集合运算不会改变参与运算的集合本身。</p>
<ul>
<li>
<p>并集： a | b 或者 a.union(b)</p>
</li>
<li>
<p>交集： a &amp; b 或者 a.intersection(b)</p>
</li>
<li>
<p>补集： a - b 或者 a.difference(b)</p>
<p>注意</p>
<p>：在字符串强制转换为集合时，必要时使用中括号先转为列表（否则字符串会被拆分为单个字符后再进行转换）。例如：</p>
<pre><code>ss = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}
ss | set(&quot;de&quot;)
{'a', 'b', 'c', 'd', 'e'}
ss | set([&quot;de&quot;])
{'a', 'b', 'c', 'de'}
</code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="基本语句">基本语句</h1>
<p>同大多数程序语言一样，Python 拥有 <code>if, for, while</code>语句。什么？<code>switch</code> 语句？使用字典就好。</p>
<h2 id="if-语句与三元操作">if 语句与三元操作</h2>
<p>在 Python 中，<code>else if</code> 被缩写为单个关键词 <code>elif</code>.</p>
<pre><code>if 1.0 &gt; 1:
    a = 1
elif 1.0 &lt; 1:
    a = 2
else:
    a = 3
    
a
3
</code></pre>
<p>值得一提的是，Python 中的 if 语句支持链式比较，形如 <code>a &lt; x &lt; b, a &lt; x &gt;= b</code> 等：</p>
<pre><code>a = 0
if 1 &lt; 2 &gt; 1.5:
    a = 1
a
1
</code></pre>
<p>三元操作实质是高度简化的 if 环境，形如 <code>X = a if flag else b</code>：</p>
<pre><code>a = 1 if 2 &lt; 1 else 2
a
2
</code></pre>
<h2 id="for-语句">for 语句</h2>
<p>Python 的循环语句中，像其他语言一样，有 <code>break</code>（跳出循环体） 与 <code>continue</code>（循环步进） 关键词可以使用。</p>
<p>for 语句借助关键词 in 使用：（函数 <code>range(N, M=0, s=1)</code> 是一个生成等差数列的函数，位于左闭右开区间<code>[M,N)</code>上且公差为 s）。</p>
<pre><code>for i in range(3):
    print(i)
0
1
2
</code></pre>
<p>注意到字典的 d.items(), d.keys(), d.values() 命令也常常用于 for 语句：</p>
<pre><code>d = {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3}
for k, v in d.items():
    print(k, v)
b 2
c 3
a 1
</code></pre>
<p>以上等价于：</p>
<pre><code>for k in d.keys():
    print(k, d[k])
b 2
c 3
a 1
</code></pre>
<p>Python 中的 <code>for</code> 语句可选 <code>else</code> 语法块，表示 <code>for</code> 语句正常结束后执行的内容（中途 <code>break</code> 不属于正常结束）。这对于处理一些 break 操作很有帮助。例如：</p>
<pre><code>a = 0
flag = 0
for i in range(5):
    if i &gt; 2:
        flag = 1
        break
if flag == 1:
    a = 1
a
1
</code></pre>
<p>这在 Python 中显得太复杂了，直接使用 <code>for…else…</code>即可：</p>
<pre><code>a = 1
for i in range(5):
    if i &gt; 1:
        break
else:
    a = 0
a
1
</code></pre>
<h2 id="while-语句">while 语句</h2>
<p>while 语句的 <code>else</code> 语法块，指明了退出 while 循环后立刻执行的内容；它不是必需的。</p>
<p>如果你想要将 while 语句内部的参数传出（比如下例的计数器终值），这是一个不错的方案。</p>
<pre><code>count = 1
while count &lt; 5:
    a = count
    count *= 2
else:
    b = count

print(a, b)
4 8
</code></pre>
<h2 id="列表解析">列表解析</h2>
<p>列表解析是一种创建列表的高度缩写方式：</p>
<pre><code>lst = [x ** 2 for x in range(4)]
lst
[0, 1, 4, 9]
</code></pre>
<p>也可以配合 if 语句：</p>
<pre><code>lst = [x ** 2 for x in range(4) if x &gt; 0]
lst
[1, 4, 9]
</code></pre>
<p>类似的，也有字典解析，以及下文会介绍的生成器，也有生成器解析（把外围的括号换成圆括号即可）：</p>
<pre><code>{n: n ** 2 for n in range(3)}
{0: 0, 1: 1, 2: 4}
</code></pre>
<h1 id="函数">函数</h1>
<p>本节介绍 Python 函数的基础特点，以及一些实用函数。</p>
<h2 id="函数定义与判断">函数定义与判断</h2>
<p>使用 <code>def</code> 关键字。三连双引号间的内容被视为函数的帮助字符串，可以通过 <code>help()</code> 命令查看。</p>
<pre><code>def func(a, b=0):
    &quot;&quot;&quot;
    This is a function that can meow.
    &quot;&quot;&quot;
    return &quot; &quot;.join([&quot;meow&quot;] * (a + b))
</code></pre>
<p>调用函数：</p>
<pre><code>func(2)  # 单参数，仅 a 
'meow meow'
func(2, 3)  # 双参数， a 与 b 都被传入
'meow meow meow meow meow'
help(func)
Help on function func in module __main__:

func(a, b=0)
    This is a function that can meow.
</code></pre>
<p>通过 <code>callable()</code> 可以判断一个对象是否是一个可调用的函数：</p>
<pre><code>callable(func)
True
</code></pre>
<h2 id="不定参函数">不定参函数</h2>
<p>利用序列（或元组）与字典，向函数传参。前者在传入时需要加上一个星号，后者需要两个。</p>
<pre><code>lst = [1, 3, 4]
d = {&quot;a&quot;: 2, &quot;b&quot;: 3, &quot;c&quot;: 5}
print(&quot;{}+{}={}&quot;.format(*lst), &quot;{a}+{b}={c}&quot;.format(**d))
1+3=4 2+3=5
</code></pre>
<h2 id="zip-函数">zip 函数</h2>
<p>zip() 函数的作用是“合并”多个列表为一个。其返回值是一个列表，列表内的元素类型是元组。如果待合并的列表长度不同，以最短的为准。</p>
<pre><code>a = [1, 2, 3, 4]
b = [5 ,6, 7]
c = &quot;abcd&quot;
list(zip(a, b, c))
[(1, 5, 'a'), (2, 6, 'b'), (3, 7, 'c')]
</code></pre>
<p>它比较常用于交换字典的键与值：</p>
<pre><code>dict(zip(d.values(), d.keys()))
{2: 'a', 3: 'b', 5: 'c'}
</code></pre>
<h2 id="lambda-函数">lambda 函数</h2>
<p>一种匿名函数的声明方式。如果你使用过 <code>MATLAB</code>，你可能熟悉这一类概念。</p>
<pre><code>func = lambda x, y: x + y
func(2, 5)
7
</code></pre>
<h2 id="map-函数">map 函数</h2>
<p><code>map()</code> 能够对传入的序列进行依次操作，并将结果返回为一个可转换为列表的 <code>map</code> 对象。通常列表解析（或生成器解析）可以实现与其同样的工作。</p>
<pre><code>lst = list(map(lambda x: x + 1, range (5)))
print(lst)
[1, 2, 3, 4, 5]
f = lambda x: x + 1
[f(x) for x in range(5)]
[1, 2, 3, 4, 5]
</code></pre>
<h2 id="filter-函数">filter 函数</h2>
<p>给定序列，对于满足某规则的部分（即 True），予以返回。</p>
<pre><code>list(filter(lambda x: x &gt; 0, range(-3, 3)))
[1, 2]
</code></pre>
<h2 id="reduce-函数">reduce 函数</h2>
<p>该函数在 Python 2 中是可以直接调用的，但在 Python 3 中需要从 <code>functools</code> 模块进行调用。</p>
<pre><code>from functools import reduce
reduce(lambda x, y: x + y, range (5))  # 0+1+2+3+4
10
</code></pre>
<h2 id="enumerate-函数">enumerate 函数</h2>
<p>它允许你像 d.items() 那样，用类似的方式操作列表：</p>
<pre><code>a = [1, 3, 5]
for i, v in enumerate(a):
    print(&quot;lst[{}] = {}&quot;.format(i, v))

lst[0] = 1
lst[1] = 3
lst[2] = 5
</code></pre>
<h1 id="装饰器算子">装饰器：算子</h1>
<p>装饰器是函数的函数——传入的参数是一个函数，返回的值也是一个函数。相当于一个函数集到另一个函数集的映射，可以理解为数学意义上的算子。</p>
<p>首先来看一个简单的例子：函数可以被赋值给一个变量。</p>
<pre><code>def pyrint(data=&quot;Python&quot;):
    return data.upper()

f = pyrint
f()
'PYTHON'
</code></pre>
<p>还可以通过 <code>__name__</code> 来得到当前函数的名称：</p>
<pre><code>f.__name__
'pyrint'
</code></pre>
<p>那什么时候需要装饰器呢？比如在函数需要被重用、但又不能直接改写 <code>def</code>的场合（在维护中应该不少见吧！）。例如，我们希望在返回值之前，把函数名也打印出来：</p>
<pre><code>def showname(func):
    def subfunc(*args, **kwarg):
        print(&quot;FUNCTION {} called.&quot;.format(func.__name__))
        return func(*args, **kwarg)
    return subfunc
</code></pre>
<p>这样如果我们通过 <code>showname(pyrint)</code> 这种形式，就能够在 <code>pyrint</code> 函数被调用之前，额外打印一行内容。</p>
<p>想要改动该函数，不需要改动 def 语句以下的内容，只需要用 <code>@showname</code> 命令来应用这个装饰器：</p>
<pre><code>@showname
def pyrint(data=&quot;Python&quot;):
    return data.upper()
pyrint()
FUNCTION pyrint called.

'PYTHON'
</code></pre>
<p>如果装饰器需要传递参数，那么，需要在定义时，外层再嵌套一个函数：</p>
<pre><code>def showname(num=1):
    def decorator(func):
        def subfunc(*args, **kwarg):
            print(&quot;Call time: {}. FUNCTION {} called.&quot;.format(num, func.__name__))
            return func(*args, **kwarg)
        return subfunc
    return decorator

@showname(2)
def pyrint(data=&quot;Python&quot;):
    return data.upper()

pyrint()
Call time: 2. FUNCTION pyrint called.

'PYTHON'
</code></pre>
<p>不过装饰器被应用于函数定义之前时，函数的 <code>__name__</code> 属性会改变。比如上例：</p>
<pre><code>pyrint.__name__
'subfunc'
使用模块 functools 来解决这一问题：

import functools

def showname(num=1):
    def decorator(func):
        @functools.wraps(func)  # 加上这一行
        def subfunc(*args, **kwarg):
            print(&quot;Call time: {}. FUNCTION {} called.&quot;.format(num, func.__name__))
            return func(*args, **kwarg)
        return subfunc
    return decorator

@showname(2)
def pyrint(data=&quot;Python&quot;):
    return data.upper()

pyrint.__name__
'pyrint'
</code></pre>
<h1 id="迭代器-itertools">迭代器 [itertools]</h1>
<p>迭代器与生成器在内存优化上很有意义。</p>
<h2 id="迭代器">迭代器</h2>
<p>迭代器最显著的特征是拥有 <code>__iter__()</code> 和 <code>__next__()</code> 方法；它像一个链表。如果它指向末尾，那么再次执行 <code>__next__()</code> 时会报错。一个例子：</p>
<pre><code>a = [1, 2, 3]
b = iter(a)
print(b.__next__(), b.__next__())  # 或者使用 next(b)
1 2
</code></pre>
<p>实际上，Python 3 内置了一个 <code>itertools</code> 的库，里面有诸如 <code>cycle</code> 和 <code>count</code> 等适用于迭代器的函数：</p>
<pre><code>import itertools

# count: 给定首项与公差的无穷等差数列
p = itertools.count(start = 1, step = 0.5)
print(p.__next__(), p.__next__())

# cycle: 周期循环的无穷序列
p = itertools.cycle(list(&quot;AB&quot;))
print(next(p), next(p), next(p))

# islice: 从无穷序列中切片
p = itertools.cycle(list(&quot;AB&quot;))
print(list(itertools.islice(p, 0, 4)))
1 1.5
A B A
['A', 'B', 'A', 'B']
</code></pre>
<p>请时刻注意当前指向的迭代器位置——失之毫厘，谬以千里。</p>
<h2 id="生成器">生成器</h2>
<p>生成器是迭代器的一种，其实质是定义中含有 yield 关键词的函数。它没有 return() 语句。</p>
<p>生成器可以直接使用类似列表解析的方式，称为生成器解析。例如：(i for i in range(10)。</p>
<pre><code>def Fib(N):  # 斐波那契数列
    n, former, later = 0, 0, 1
    while n &lt; N:
        yield later
        former, later = later, later + former
        n += 1

list(Fib(5))
[1, 1, 2, 3, 5]
</code></pre>
<p>上例与普通的写法看上去差别不大，但实际上可以将 while 语句改写为 <code>while True</code>，删除变量 n，在外部借助 itertools 的 <code>islice</code> 函数来截取。这在函数定义时对代码的压缩是显然的。</p>
<pre><code>def iterFib():
    former, later = 0, 1
    while True:
        yield later
        former, later = later, later + former

list(itertools.islice(iterFib(), 0, 5))
[1, 1, 2, 3, 5]
</code></pre>
<h1 id="错误try-语句">错误：<code>try()</code> 语句</h1>
<p>常见的错误有以下几种：</p>
<ul>
<li>
<p>ZeroDivisionError: 除数为 0.</p>
</li>
<li>
<p>SyntaxError：语法错误。</p>
</li>
<li>
<p>IndexError：索引超界。</p>
</li>
<li>
<p>KeyError：字典键不存在。</p>
</li>
<li>
<p>IOError：读写错误。</p>
<p>try() 语句的常见写法：</p>
<pre><code>try:
    a = 1 
except ZeroDivisionError as e:
    print(e)
    exit()
else:  # 如果无错误，执行
    print(a)
finally:  # 不管有无错误均执行
    print(&quot;-- End --&quot;)
1
-- End --
</code></pre>
</li>
</ul>
<p>其中，<code>else</code> 与 <code>finally</code> 语句都不是必需的。如果不想输出错误信息、或不能预先判断可能的错误类型，可以使用仅含 exit() 语句的 <code>except</code> 块。</p>
<h2 id="多个-except-块">多个 except 块</h2>
<p>一个 try 语法块是可以跟着多个 <code>except</code> 的；如果靠前的 except 捕获了错误，之后的就不会运行。 这也就是说，如果错误之间有继承关系时，子错误需要放在父错误之前尝试 except，否则子错误永远也不可能被捕获。</p>
<p>比如上一节的例子中，<code>ZeroDivisionError</code> 是 <code>ArithmeticError</code> 下的子错误，而 <code>ArithmeticError</code> 又是 Exception 下的子错误（当不清楚错误的类型时，Exception 可以捕获绝大多数错误）。关于错误的继承关系，参考：Python - Exception Hierarchy 官方页面。</p>
<p>一个例子：</p>
<pre><code>try:
    a = 1 / 0
except Exception:
    print(&quot;Exception&quot;)
    exit()
except ZeroDivisionError:
    print(&quot;ZeroDivisionError&quot;)
    exit()
else:
    print(&quot;No error.&quot;)
finally:
    print(&quot;-- End --&quot;)
输出 Exception 与 – End –。
</code></pre>
<h2 id="错误的捕获">错误的捕获</h2>
<p>错误在很多地方都可能发生，那是否需要在可能的地方都加上 try 语句呢？当然不是。建议只在主代码中加入 try 语句，因为 Python 会自动跟踪到错误产生的源头何在。</p>
<h2 id="错误的抛出及上抛">错误的抛出及上抛</h2>
<p>有时候我们想人为抛出一个错误，这是使用 <code>raise</code> 即可：</p>
<pre><code># raise TypeError(&quot;Wrong type.&quot;)
</code></pre>
<p>如果在函数中没有处理错误的语句，可能在捕获错误后将其上抛。记住，捕获错误只是为了记录错误的产生，并不意味者必须原地解决错误。</p>
<pre><code>def makeerror(n):
    if n == 0:
        raise ValueError(&quot;Divided by zero.&quot;)
    return 1 / n

def callerror():
    try:
        makeerror(0)
    except ValueError as e:
        print(&quot;ValueError detected.&quot;)
        raise

# 输出 &quot;ValueError detected.&quot; 并打印错误日志
# callerror()
</code></pre>
<p>上面的 <code>raise</code> 命令没有紧跟任何参数，表示将错误原样上抛。你也可以手动指定上抛的错误类型，并不需要与原错误类型一致。甚至你可以定义一个错误（继承某一错误类）：</p>
<pre><code>class MyError(ValueError):
    print(&quot;This is MyError.&quot;)

# raise MyError
This is MyError.
</code></pre>
<h1 id="文件读写">文件读写</h1>
<p>open() 函数用于文件的读写操作。一般我们会在操作文件时，引入 os 模块（os 模块的用法参考“常用模块”一节的内容）。</p>
<pre><code>import os
</code></pre>
<p><code>open()</code> 函数常常配合 <code>with</code> 语法块进行使用，它会在语法块结束时自动关闭文件。该函数：</p>
<pre><code>open(file, mode=&quot;r&quot;, encoding=None)
</code></pre>
<p>第一参数是包含文件名的路径（传入基于当前目录的相对路径，传入或者绝对路径），mode 参数是读写操作方式；<code>encoding</code> 是编码类型，一般取<code>”utf8”</code>。其中，读写操作方式常用的有：</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">“r”</td>
<td style="text-align:center">（默认）读。</td>
</tr>
<tr>
<td style="text-align:center">“w”</td>
<td style="text-align:center">写。该模式会覆盖原有内容；如文件不存在，会自动新建。</td>
</tr>
<tr>
<td style="text-align:center">“x”</td>
<td style="text-align:center">创建新文件并写入。</td>
</tr>
<tr>
<td style="text-align:center">“a”</td>
<td style="text-align:center">在已有文件的尾部追加。</td>
</tr>
</tbody>
</table>
<h2 id="一般读写操作read-readlines">一般读写操作：<code>read() / readlines()</code></h2>
<p>函数 <code>read()</code> 将整个文件读为一个字符串，来看一个例子：</p>
<pre><code>datapath = os.path.join(os.getcwd(), &quot;data&quot;, &quot;iris.data.csv&quot;)
with open(datapath, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:
    rawtext = f.read()

rawtext[:200]
'5.1,3.5,1.4,0.2,Iris-setosa\n4.9,3.0,1.4,0.2,Iris-setosa\n4.7,3.2,1.3,0.2,Iris-setosa\n4.6,3.1,1.5,0.2,Iris-setosa\n5.0,3.6,1.4,0.2,Iris-setosa\n5.4,3.9,1.7,0.4,Iris-setosa\n4.6,3.4,1.4,0.3,Iris-setosa\n5.0,'
</code></pre>
<p>函数 <code>readlines()</code> 将整个文件读为一个列表，文件的每一行对应列表的一个元素。</p>
<pre><code>with open(datapath, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:
    rawtext = f.readlines()

rawtext[:3]
['5.1,3.5,1.4,0.2,Iris-setosa\n',
 '4.9,3.0,1.4,0.2,Iris-setosa\n',
 '4.7,3.2,1.3,0.2,Iris-setosa\n']
</code></pre>
<p>上述的 <code>readlines()</code> 函数实质等同于列表解析：</p>
<pre><code>with open(datapath, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:
    rawtext = [line for line in f]

rawtext[:3]
['5.1,3.5,1.4,0.2,Iris-setosa\n',
 '4.9,3.0,1.4,0.2,Iris-setosa\n',
 '4.7,3.2,1.3,0.2,Iris-setosa\n']
</code></pre>
<p>文件写入，使用 <code>write()</code> 函数。一个简单的例子：</p>
<pre><code>with open(datapath, &quot;w&quot;) as f:
   f.write(&quot;Sometimes naive.&quot;)
</code></pre>
<h2 id="大文件读取readline">大文件读取：<code>readline()</code></h2>
<p>如果文件比较大，使用 <code>read()/readlines()</code> 函数直接读入可能会占用太多内存。推荐使用函数 <code>readline()</code>，一种迭代器式的读取方法。</p>
<pre><code>with open(datapath, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:
    print(f.readline().strip())
    print(f.readline().strip())
5.1,3.5,1.4,0.2,Iris-setosa
4.9,3.0,1.4,0.2,Iris-setosa
</code></pre>
<p>你会发现两次结果是不同的，这是因为迭代器内部的“指针”向后移动了。</p>
<p>怎样获取 / 移动“指针”的位置呢？使用 tell() / seek() 命令。</p>
<pre><code>with open(datapath, &quot;r&quot;, encoding=&quot;utf8&quot;) as f:
    print(f.tell(), f.readline().strip())
    print(f.tell(), f.readline().strip())
    f.seek(0)  # 回到文件头
    print(f.tell(), f.readline().strip())
0 5.1,3.5,1.4,0.2,Iris-setosa
28 4.9,3.0,1.4,0.2,Iris-setosa
0 5.1,3.5,1.4,0.2,Iris-setosa
</code></pre>
<h1 id="类">类</h1>
<p>类的成员包括属性（<code>attribute</code>）与方法（<code>method</code>）两种。例子：</p>
<pre><code>class MyClass:
    &quot;&quot;&quot;
    This is a class that can meow!
    &quot;&quot;&quot;
    animal = &quot;cat&quot;  # An attribute
    def talk(self):  # A method
        return &quot;Meow&quot;

# An instance of the class
a = MyClass()
print(a.animal, a.talk())
cat Meow
</code></pre>
<p>上例中的 <code>self</code> 表示类的实例，所有类内部的方法都需要把该参数放在首位（你也不可不用 self 而使用 this 等，但是 <code>self</code> 是惯例）。例如，<code>self.animal</code> 就表示了实例的 animal 属性。这与 C# 等语言中的“this.animal”是类似的。</p>
<p>下例证明了 <code>self</code> 代表的实质是类的实例，而不是类本身。</p>
<pre><code>class EgClass:
    def __init__(self):
        print(self)  # 实例，有对应地址
        print(self.__class__)  # 类

a = EgClass()
&lt;__main__.EgClass object at 0x000002531C0AF860&gt;
&lt;class '__main__.EgClass'&gt;
</code></pre>
<h2 id="构造函数__init__">构造函数：<code>__init__()</code></h2>
<p>类的构造函数是 <code>__init__()</code> （左右均为双下划线），用于初始化实例。在声明实例时，该函数自动被调用。</p>
<pre><code>class MyClass2:
    def __init__(self, animal=&quot;cat&quot;):
        self.animal = animal

a = MyClass2(&quot;dog&quot;)
a.animal
'dog'
</code></pre>
<h2 id="封装">封装</h2>
<p>类的重要特性是封装性，即部分变量只能在其内部修改或访问，不能从类的外部进行处理。Python 中的封装非常简单，只要把属性或方法的名称前缀设置为双下划线即可。</p>
<p>由此可见，构造函数 <code>__init__()</code> 是最基本的一个私有方法。一个例子：</p>
<pre><code>class MyClass3:
    def __init__(self, animal=&quot;cat&quot;):
        self.__animal = animal
        self.__foo()
    def __foo(self):
        self.__animal = &quot;rabbit&quot;
    def show(self):
        print(self.__animal)

a = MyClass3(&quot;dog&quot;)
a.show()
rabbit
</code></pre>
<p>如果想直接调用 <code>__foo() 或者 __animal</code>，都会被禁止，产生 <code>AttributeError</code>。</p>
<pre><code># a.__animal  # AttributeError
</code></pre>
<p>要注意，前后均添加了双下划线的属性，如 <strong>name</strong> ，表示特殊属性而不是私有属性，是可以从外部访问的。</p>
<h2 id="继承">继承</h2>
<p>下面是一个著名的猫与狗的例子；类 Cat 与 Dog 都继承自 Animal，同时也都重载了方法 talk()。</p>
<pre><code>class Animal:
    def talk(self):
        pass # 表示定义留空

class Cat(Animal): # 从Animal 继承
    def talk(self): # 重写talk()
        print('Meow')

class Dog(Animal):
    def talk(self):
        print('Woof')

a, b = Cat(), Dog()
a.talk() # 'Meow'
b.talk() # 'Woof'
Meow
Woof
</code></pre>
<p>通过 <code>isinstance()</code> 函数可以判断一个对象是否是某个类（或其子类）的实例：</p>
<pre><code>print(isinstance(a, Cat), isinstance(a, Animal))
True True
或者：

type(a).__name__
'Cat'
</code></pre>
<p>当然，类也可以多继承。写在左侧的类的属性与方法，在继承时会被优先采用。例如：</p>
<pre><code>class Pet:
    def talk(self):
        print(&quot;Pet&quot;)

class Cat2(Pet, Cat):
    pass

a = Cat2()
a.talk()
Pet
</code></pre>
<h2 id="property-装饰器">@property 装饰器</h2>
<p>装饰器 <code>@property</code>可以被用于限制类属性的读写行为。比如，一个普通的类，如果想封装一个属性，却允许从外部读取它的值，一般我们用 <code>getter</code> 函数实现：</p>
<pre><code>class Person:
    def __init__(self):
        self.__name = &quot;Py&quot;
    def get_name(self):
        return self.__name
a = Person()
a.get_name()
'Py'
</code></pre>
<p>不得不说这实在是麻烦了，代码里一堆 get 函数满天飞并不令人愉快。而且还不能忘记它是一个函数，需要在尾部加上括号。</p>
<p>装饰器 <code>@property</code> 可以将一个方法伪装成同名的属性，因此装饰了 <code>getter</code> 函数后，调用时就不用加上尾部的括号了：</p>
<pre><code>class Person:
    def __init__(self):
        self.__name = &quot;Py&quot;
        
    @property
    def name(self):
        return self.__name
a = Person()
a.name
'Py'
</code></pre>
<p>而且，如果你想从外部修改该属性的值，会产生错误：</p>
<pre><code>a.name = 1
---------------------------------------------------------------------------

AttributeError                            Traceback (most recent call last)

&lt;ipython-input-97-8c607f2aa25b&gt; in &lt;module&gt;()
----&gt; 1 a.name = 1


AttributeError: can't set attribute
</code></pre>
<p>但同时，我们也可以指定其 setter 函数（该装饰器 @age.setter 在用 @property 装饰 age 方法后会自动生成），让属性修改成为可能，甚至附加修改条件：</p>
<pre><code>class Person:
    def __init__(self):
        self.__age = 20
        
    @property
    def age(self):
        return self.__age
    
    @age.setter
    def age(self, value):
        if not isinstance(value, int):
            raise ValueError(&quot;Age should be an integer.&quot;)
        else:
            self.__age = value
a = Person()
a.age = 30
a.age
30
</code></pre>
<p>不传入整数会报错：</p>
<pre><code>a.age = 0.5
---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

&lt;ipython-input-100-001bfa8fe26b&gt; in &lt;module&gt;()
----&gt; 1 a.age = 0.5


&lt;ipython-input-98-83364d5faa13&gt; in age(self, value)
     10     def age(self, value):
     11         if not isinstance(value, int):
---&gt; 12             raise ValueError(&quot;Age should be an integer.&quot;)
     13         else:
     14             self.__age = value


ValueError: Age should be an integer.
</code></pre>
<h2 id="类的特殊属性与方法">类的特殊属性与方法</h2>
<h3 id="属性-__dict__">属性 <code>__dict__</code></h3>
<p>首先是 <code>__dict__</code>属性，用于查看类的属性与方法，返回一个字典。</p>
<pre><code>a = MyClass()
MyClass.__dict__
mappingproxy({'__dict__': &lt;attribute '__dict__' of 'MyClass' objects&gt;,
              '__doc__': '\n    This is a class that can meow!\n    ',
              '__module__': '__main__',
              '__weakref__': &lt;attribute '__weakref__' of 'MyClass' objects&gt;,
              'animal': 'cat',
              'talk': &lt;function __main__.MyClass.talk&gt;})
</code></pre>
<p>需要注意的是，此时实例 a 的属性没有被更改过，实例的 <strong>dict</strong> 是一个空字典：</p>
<pre><code>print(a.__dict__, a.animal)
{} cat
</code></pre>
<p>类的 <code>__dict__</code> 方法下的同名键，与实例具有相同值。</p>
<pre><code>MyClass.__dict__[&quot;animal&quot;]
'cat'
</code></pre>
<p>一旦被从外部更改，实例 a 的 <strong>dict</strong> 字典就不再为空。</p>
<pre><code>a.animal = &quot;dog&quot;
print(a.__dict__, a.animal)
{'animal': 'dog'} dog
</code></pre>
<h3 id="属性-__slots__">属性 <code>__slots__</code></h3>
<p>从上面可以看到，非私有的类属性可以从外部更改值，而且属性还能直接从外部增加。<strong>slots</strong> 属性的作用就在于使类的属性不能从外部进行更改、追加。它能够限制属性滥用，并在优化内存上也有意义。</p>
<pre><code>class MySlotClass():
    __slots__ = (&quot;meow&quot;, &quot;woof&quot;)
    def __init__(self):
        self.meow = &quot;Meow&quot;
        self.woof = &quot;Woof&quot;
    
a = MySlotClass()
MySlotClass.__dict__
mappingproxy({'__doc__': None,
              '__init__': &lt;function __main__.MySlotClass.__init__&gt;,
              '__module__': '__main__',
              '__slots__': ('meow', 'woof'),
              'meow': &lt;member 'meow' of 'MySlotClass' objects&gt;,
              'woof': &lt;member 'woof' of 'MySlotClass' objects&gt;})
</code></pre>
<p>此时，如果使用 <code>a.__dict__</code>，结果不会返回空字典，而是会报错。</p>
<h3 id="运算符重载">运算符重载</h3>
<p>特别地，Python 提供了运算符重载的功能。常用的对应如下（参考 官方页面）：</p>
<p>方法 含义 应用<br>
一元运算符<br>
<strong>len</strong> 长度 len(a)<br>
<strong>bool</strong> 逻辑值 bool(a)<br>
<strong>neg</strong> 取负值 -a<br>
<strong>str</strong> / <strong>repr</strong> 字符串形式 repr(a) / str(a), print(a)<br>
二元运算符<br>
<strong>add</strong> 加 a + b, a += b<br>
<strong>sub</strong> 减 a - b, a -= b<br>
<strong>mul</strong> 乘 a <em>b, a</em> = b<br>
<strong>div</strong> 除 a / b, a /= b<br>
<strong>pow</strong> 乘方 a <strong>b, a</strong> = b<br>
<strong>radd</strong> 左加 … + a<br>
二元关系符<br>
<strong>lt</strong> / <strong>le</strong> 小于 / 小于等于 a &lt; b, a &lt;= b<br>
<strong>gt</strong> / <strong>ge</strong> 大于 / 大于等于 a &gt; b, a &gt;= b<br>
<strong>eq</strong> / <strong>ne</strong> 等于 / 不等于 a == b, a != b<br>
比如下例中，对多个运算进行了重载，完成了二维向量在加减法上与向量、与数运算的基本定义。</p>
<pre><code>class Vector:
    def __init__(self, a, b):
        self.a = a
        self.b = b
   
    def __add__(self, another):
        if isinstance(another, Vector):
            c, d = another.a, another.b
        else:
            c, d = another, another
        return Vector(self.a + c, self.b + d)
    
    def __radd__(self, another):
        return self.__add__(another)
    
    def __neg__(self):
        return Vector(-self.a, -self.b)
    
    def __sub__(self, another):
        return self.__add__(-another)
    
    def __str__(self):
        return &quot;Vector({},{})&quot;.format(self.a, self.b)

v1 = Vector(0,3)
v2 = Vector(5,-2)
print(v1 - 1, -v2, v1 + v2, v1 - v2)
Vector(-1,2) Vector(-5,2) Vector(5,1) Vector(-5,5)
</code></pre>
<p>其中，<code>__repr__()</code> 与 <code>__str__()</code> 的主要区别在于，前者在交互式步骤中显示结果，后者在 print 函数中显示结果。</p>
<p>例如上例，如果直接输入 v1，不会以 “Vector(0,3)”的形式显示。</p>
<pre><code>v1  # 在类中附加定义： __repr__ = __str__ 即可解决问题。
&lt;__main__.Vector at 0x2531c129c88&gt;
</code></pre>
<h2 id="迭代行为">迭代行为</h2>
<p>在类中也能定义迭代行为，需要 <strong>iter</strong>() 与 <strong>next</strong>() 方法。</p>
<pre><code># 该例改编自官方文档
class MyClass4:
    def __init__(self, lst):
        self.data = lst
        self.__index = len(lst)
    def __iter__(self):
        return self
    def __next__(self):
        if self.__index == 0:
            raise StopIteration
        self.__index -= 1
        return self.data[self.__index]

a = MyClass4(&quot;Meow&quot;)
for char in a:
    print(char)
w
o
e
M
</code></pre>
<h1 id="常用模块">常用模块</h1>
<p>下面介绍几个常用的 Python 标准模块（即随 Python 安装的模块）。更多的第三方模块，例如 NumPy, pandas, matplotlib，可以参考本系列博文的其他文章。</p>
<h2 id="os-模块">os 模块</h2>
<p>这个模块应该是 Python 自带模块中使用率最高的一个了。一些例子：</p>
<pre><code># import os
#
# ----- 文件操作 -----
# os.rename(&quot;old.py&quot;, &quot;new.py&quot;)  # 重命名
# os.remove(&quot;a.py&quot;)  # 删除
# os.stat(&quot;b.py&quot;)  # 查看文件属性
#
# ----- 路径操作 -----
# os.getcwd()  # 获取当前目录
# os.chdir(r&quot;d:\list&quot;)  # 更改当前目录为
# os.chdir(os.pardir)  # 返回上一级目录
# os.mkdir('newfolder ')  # 在当前目录新建一个文件夹
# os.listdir('c:\list')  # 列出文件夹下所有文件的列表
# os.removedirs('thefolder ')  # 删除空文件夹
# os.path.isfile/ispath(&quot;f&quot;)  # 检查路径是文件或是目录
# os.path.exists(&quot;f&quot;)  # 检查路径是否存在
# 
# ----- 操作平台相关 -----
# os.sep  # 当前操作系统的路径分隔符
# os.linesep  # 当前操作系统的换行符
# os.path.join(r&quot;c:\abc&quot;, &quot;d&quot;)  # 连接字串成为路径
</code></pre>
<h2 id="sys-模块">sys 模块</h2>
<p>一般我很少用到这个模块。可能有这么几个命令会用到：</p>
<ul>
<li>
<p>sys.argv：能够传递从命令行接受的参数到代码内。</p>
</li>
<li>
<p>sys.platform：当前操作系统平台。</p>
</li>
<li>
<p>sys.exit()：无参数时抛出 SystemExit 错误并退出；有参数时会在退出前输出对应的字符串到屏幕。</p>
<pre><code>import sys
sys.platform
'win32'
</code></pre>
</li>
</ul>
<p>一个 <code>sys.argv</code> 的例子：</p>
<pre><code>sys.argv
['e:\\python\\lib\\site-packages\\ipykernel_launcher.py',
 '-f',
 'C:\\Users\\wklchris\\AppData\\Roaming\\jupyter\\runtime\\kernel-3724c4c9-2130-485d-b388-7a84379fd043.json']
</code></pre>
<p>以上不是典型的例子，因为并不是在命令行下运行的。命令行下通常有如下格式：</p>
<pre><code>python test.py hello
</code></pre>
<p>此时，sys.argv[0] = test.py，sys.argv[1] = hello.</p>
<h2 id="re-模块正则表达式">re 模块：正则表达式</h2>
<p>参考本文附录。</p>
<h2 id="其他模块">其他模块</h2>
<ul>
<li>collection 模块：
<ul>
<li>提供了一种双端列表 deque，可以用 appendleft, extendleft, popleft 等方法从 deque 的左侧（也就是lst[0]）进行操作。注意，deque 的更新操作比 list 更快，但读取操作比 list 慢。</li>
<li>提供了一种缺省字典<code>defaultdict</code>，可以直接操作键值（即使这个键先前未定义）；首次操作时会赋一个合理的初值，比如首次调用 d[“a”] += 1 而字典本身没有 “a” 键时，会自动初始化 “a” 键并赋初值 0。</li>
</ul>
</li>
<li>calendar 模块：判断星期、闰年，输出日历等等。</li>
<li>itertools 模块：在本文“迭代器”小节已进行了简要介绍。</li>
<li>logging 模块：在调试中可能会使用。</li>
<li>urllib 模块：这是一个 HTML 请求模块，常用于爬虫。</li>
</ul>
<h1 id="调试与测试">调试与测试</h1>
<p>Python 中有一些内置的办法进行调试与测试。</p>
<h2 id="断言assert">断言：assert</h2>
<p>断言的含义在于，如果断言失败（False），那么代码会被终止（抛出一个<code>AssertionError</code>）。比如：</p>
<pre><code>n = 0
assert(n != 0)
1 / n
---------------------------------------------------------------------------

AssertionError                            Traceback (most recent call last)

&lt;ipython-input-112-e53f92f6c644&gt; in &lt;module&gt;()
      1 n = 0
----&gt; 2 assert(n != 0)
      3 1 / n


AssertionError:
</code></pre>
<p>与大家一贯喜欢使用的 print 调试法相比，断言语句可以用命令行参数 -O 忽略。这样所有的 assert() 语句都不会被执行。</p>
<pre><code>$ python -O main.py
</code></pre>
<h2 id="日志调试logging-模块">日志调试：logging 模块</h2>
<p>logging 模块支持将错误日志输出（到控制台或者到文件）。</p>
<p>此乃调试神器。延伸阅读： logging 官方基础教程。</p>
<pre><code>import logging
# 该行也可能通过控制台：$ python main.py --log=WARNING 的方式实现
logging.basicConfig(level=logging.WARNING)
n = 0
logging.warning(&quot;n = {}&quot;.format(n))
WARNING:root:n = 0
</code></pre>
<p>logging 模块的灵活之处在于你可以记录信息的级别（<code>DEBUG，INFO，WARNING，ERROR，CRITICAL</code>），各级别的作用如下：</p>
<ul>
<li>
<p>DEBUG：最详细的级别，所有详细日志都会被输出。</p>
</li>
<li>
<p>INFO：检测代码是否按照预期执行。</p>
</li>
<li>
<p>WARNING：非预期的事件发生了，或者可能在近期发生（例如：低磁盘空间）。但代码仍然执行。</p>
</li>
<li>
<p>ERROR：发生了级别更高的问题，某些功能无法正常实现。</p>
</li>
<li>
<p>CRITICAL：严重错误，代码可能无法继续运行。</p>
<p>通过</p>
<pre><code>filename
</code></pre>
<p>参数，可以将日志写入到文件。一般使用</p>
<pre><code>DEBUG
</code></pre>
<p>级别，即输出所有信息。</p>
<pre><code># logging.basicConfig(filename=&quot;log.log&quot;, level=logging.DEBUG)
</code></pre>
</li>
</ul>
<p>默认会将日志追加到文件末尾，如果想要覆写文件而不是追加，使用 filemode 参数：</p>
<pre><code># logging.basicConfig(filename=&quot;log.log&quot;, filemode=&quot;w&quot;, level=logging.DEBUG)
</code></pre>
<p>更改日志格格式，使用 format 参数。一般来说，常用的格式码（格式码后加 s 表示字符串）有：</p>
<ul>
<li>
<p><code>%(levelname)</code>：当前日志字串级别。</p>
</li>
<li>
<p><code>%(message)</code>：当前日志字串。</p>
</li>
<li>
<pre><code>%(asctime)
</code></pre>
<p>：当前时间。默认 datefmt 参数为</p>
<pre><code>%Y-%m-%d %I:%M:%S
</code></pre>
<p>例子。下例会输出形如：”01/23/1900 08:05:05 PM is when this event was logged.” 这样的格式。</p>
<pre><code># logging.basicConfig(format='%(asctime)s %(message)s', datefmt='%m/%d/%Y %I:%M:%S %p')
# logging.warning('is when this event was logged.')
# 常用的格式：
# logging.basicConfig(format=&quot;%(levelname)s: %(message)s&quot;)
</code></pre>
</li>
</ul>
<p>还可以通过配置文件来代替 basicConfig 命令，并进行设置 logger 等更高级的配置。这部分可以参考：此处。</p>
<pre><code># import logging.config

# logging.config.fileConfig('logging.conf')
</code></pre>
<h1 id="附录正则表达式">附录：正则表达式</h1>
<p>正则表达式的基础内容参考本博客的这篇博文：正则表达式。注意：如果要保存一个正则表达式供多次使用，请存储其 <code>compile</code> 后的结果，避免反复编译。</p>
<ul>
<li>
<p>re.compile(exp)：编译正则表达式。</p>
</li>
<li>
<p>re.compile(exp).match(str)：判断正则表达式能否匹配一个字串。可以 bool() 结果来获知是否匹配。</p>
<ul>
<li>re.compile(exp).match(str).groups()：将匹配结果返回为单个字符串（无子组时）或元组（有子组时）。</li>
<li>re.compile(exp).findall(str)：找出字符串中所有匹配表达式的子串。返回列表。</li>
</ul>
</li>
<li>
<p>re.split(exp, str)：用表达式来分割字符串，相当于 str.split() 的增强版。</p>
<pre><code>import re
bool(re.match(r&quot;\d&quot;, &quot;1&quot;))
True
phone_re = re.compile(r'\d{3,4}-\d{7,8}')
phone_re.match('010-12345678').group()
'010-12345678'
# 如果在正则表达式中添加了子组（小括号），那么会返回子组依顺序组成的一个元组
phone_re = re.compile(r'(\d{3,4})-(\d{7,8})')
phone_re.match('010-12345678').groups()
('010', '12345678')
phone_re = re.compile(r'\d{3,4}-\d{7,8}')  # 寻找所有子串
phone_set = '010-12345678, 021-65439876 '
phone_re.findall(phone_set)
['010-12345678', '021-65439876']
s = 'a b   c'  # 用 re.split() 处理连续的空格
print(s.split(' '), re.split(r&quot;\s+&quot;, s))
['a', 'b', '', '', 'c'] ['a', 'b', 'c']
</code></pre>
</li>
</ul>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://xiong-zh.github.io/tag/yaI-h-rVLi">
            <span class="flex-auto">Python</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://xiong-zh.github.io/post/Django操作数据库原生SQL初体验">
                <h3 class="post-title">
                  <i class="remixicon-arrow-left-line"></i>
                  Django操作数据库原生SQL初体验
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://xiong-zh.github.io/post/sublime使用总结">
                <h3 class="post-title">
                  sublime使用总结
                  <i class="remixicon-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '7691fdf5a3780e9bb3a4',
    clientSecret: 'f4bd6c2287489e6b24a18af94afd54efcd0f55f9',
    repo: 'xiong-zh.github.io',
    owner: 'xiong-zh',
    admin: ['xiong-zh'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="https://xiong-zh.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()

let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
