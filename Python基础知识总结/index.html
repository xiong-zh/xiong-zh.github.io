<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Python基础知识总结 | ZhangXiong</title>
<meta name="description" content="当地比较有趣的一类人." />
<link rel="shortcut icon" href="https://xiong-zh.github.io/favicon.ico?v=1583041260308">
<link href="https://cdn.remixicon.com/releases/v1.3.1/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">

<link rel="stylesheet" href="https://xiong-zh.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Python基础知识总结 | ZhangXiong - Atom Feed" href="https://xiong-zh.github.io/atom.xml">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-156420077-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-156420077-1');
</script>


  </head>
  <body>
    <div class="site-nav has-cover">
      <div class="head">
  <div class="inner">
    <a class="site-name" href="https://xiong-zh.github.io">
        <span>ZhangXiong</span>
    </a>
    <label class="burger" for="burger"></label>
    <input id="burger" type="checkbox">
    <button class="burger">
      <div>
        <span></span>
        <span></span>
      </div>
    </button>
    <nav class="info_nav">
      
        
          <a href="/">回到首页</a>
        
      
        
          <a href="/archives">文章归档</a>
        
      
        
          <a href="/tags">所有标签</a>
        
      
        
          <a href="/documents/" target="_blank">后端图谱</a>
        
      
        
          <a href="/friends/">友情链接</a>
        
      
        
          <a href="/about">关于</a>
        
      
    </nav>
  </div>
</div>
    </div>
    <article role="main" class="hentry has-cover">
      
        <div class="entry-cover js-cover" data-src="http://picture.zhangxiong.net/images/blog_picture/cover/053.jpg" data-width="900" data-height="423" style="background-image:url(http://picture.zhangxiong.net/images/blog_picture/cover/053.jpg); height: 80vw;">
          <h1 class="post-title">Python基础知识总结</h1>
        </div>
      
      <h1 class="entry-title" itemprop="headline">Python基础知识总结</h1>
      <div class="entry-meta">
        <time class="updated" datetime="2020-01-15 11:50:31">2020-01-15</time>
        <span class="author vcard">
          20 min read
        </span>
      </div>
      <div class="post-content yue">
        <p>Python 的火热度怕是大家已经早已感受到了，很多程序员将 Python 作为了他的第二语言，如果你至今还未接触任何和 Python 相关的知识，那么今天我带给你的这篇文章可以让你快速了解 Python 语法，上手做东西了。</p>
<!--more-->
<h1 id="python基础知识总结">Python基础知识总结</h1>
<p>Python 是著名的 “龟叔” Guido van Rossum 在 1989 年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。</p>
<p>Python 的火热度怕是大家已经早已感受到了，很多程序员将 Python 作为了他的第二语言，如果你至今还未接触任何和 Python 相关的知识，那么今天我带给你的这篇文章可以让你快速了解 Python 语法，上手做东西了。</p>
<h2 id="python-语言的特点">Python 语言的特点</h2>
<h3 id="python-是一种解释性语言">Python 是一种解释性语言</h3>
<p>编译型语言：在程序执行前，会通过编译器将程序（代码）转换为机器语言（计算机可以看懂的语音），比如C语音。</p>
<p>解释型语言：没有编译过程，在程序执行的时候通过解释器对程序逐行解释然后直接运行。</p>
<p>比较：因为编译型语音在执行前已经做了编译（翻译给计算机），所以执行比较快（执行过程中不需要翻译）。</p>
<figure data-type="image" tabindex="1"><a href="https://dp2px.com/post/python-jichu/image1.jpg"><img src="https://dp2px.com/post/python-jichu/image1.jpg" alt="img" loading="lazy"></a></figure>
<p>事实上，解释性语言还有一个缺点就是不能实现加密，如果要发布你的 Python 程序，实际上就是发布源代码，这一点跟 C/Java 等语言不同。当然了我们也不需要在意这些，如果你要写一个程序卖给别人可能会造成影响，大多数商业模式是售卖服务，所以不存在源码公开问题。</p>
<h3 id="python-是面向对象的语言">Python 是面向对象的语言</h3>
<p>面向过程：一般就是先分析解决问题需要的步骤，然后用函数把这些步骤一步步实现，然后依次调用（比较接近计算机的思考方式）。</p>
<p>面向对象：把问题中的各个事物分解（抽象）成各个对象，通过对象之间交互来实现（和我们人类的思考方式更接近）。</p>
<h3 id="python-比较适合初学者">Python 比较适合初学者</h3>
<p>Python 有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单。</p>
<h2 id="python开发环境搭建">Python开发环境搭建</h2>
<h3 id="安装">安装</h3>
<p>Python 官网：https://www.python.org/</p>
<p>Python 可应用于多平台包括 Linux 和 Mac OS X。</p>
<p>你可以通过终端窗口输入 <code>python</code> 命令来查看本地是否已经安装 Python 以及 Python 的安装版本。</p>
<ul>
<li>Unix (Solaris, Linux, FreeBSD, AIX, HP/UX, SunOS, IRIX, 等等。)</li>
<li>Win 9x/NT/2000</li>
<li>Macintosh (Intel, PPC, 68K)</li>
<li>OS/2</li>
<li>DOS (多个DOS版本)</li>
<li>PalmOS</li>
<li>Nokia 移动手机</li>
<li>Windows CE</li>
<li>Acorn/RISC OS</li>
<li>BeOS</li>
<li>Amiga</li>
<li>VMS/OpenVMS</li>
<li>QNX</li>
<li>VxWorks</li>
<li>Psion</li>
</ul>
<p><a href="https://dp2px.com/post/python-jichu/image1"><img src="https://dp2px.com/post/python-jichu/image1" alt="windows 通过 win+q 快捷键打开 python" loading="lazy"></a>windows 通过 win+q 快捷键打开 python</p>
<p>IDLE 是 Python 软件包自带的一个集成开发环境，初学者可以利用它方便地创建、运行、测试和调试 Python 程序。</p>
<h3 id="第一个-python-程序">第一个 Python 程序</h3>
<p><a href="https://dp2px.com/post/python-jichu/image2"><img src="https://dp2px.com/post/python-jichu/image2" alt="第一个 python 程序" loading="lazy"></a>第一个 python 程序</p>
<p>在 IDLE 中输入编写 python 的第一个程序在控制台输入 <code>hello world</code>，接下来我们看在 windows 命令行如何执行 python.</p>
<p>为了在命令行执行 python 方便首先需要配置一下环境变量:</p>
<p><a href="https://dp2px.com/post/python-jichu/image3"><img src="https://dp2px.com/post/python-jichu/image3" alt="配置环境变量" loading="lazy"></a>配置环境变量</p>
<p>启用 command line (命令行）：</p>
<p><a href="https://dp2px.com/post/python-jichu/image4"><img src="https://dp2px.com/post/python-jichu/image4" alt="启用 command line" loading="lazy"></a>启用 command line</p>
<p>在命令行输入 python，然后编写我们的 helloworld 程序：</p>
<p><a href="https://dp2px.com/post/python-jichu/image5"><img src="https://dp2px.com/post/python-jichu/image5" alt="命令行书写python的第一个程序" loading="lazy"></a>命令行书写python的第一个程序</p>
<p>在Python的交互式命令行写程序，好处是一下就能得到结果，坏处是没法保存，下次还想运行的时候，还得再敲一遍。所以，实际开发的时候，我们总是使用一个文本编辑器来写代码，写完了，保存为一个文件，这样，程序就可以反复运行了。</p>
<h2 id="python-的数据类型">Python 的数据类型</h2>
<h3 id="变量">变量</h3>
<p>变量存储在内存中的值。这就意味着在创建变量时会在内存中开辟一个空间。变量的本质是内存中一段存储空间（大小由数据类型决定），变量名和这段存储空间的地址发生关联。基于变量的数据类型，解释器会分配指定内存，并决定什么数据可以被存储在内存中。变量可以指定不同的数据类型，这些变量可以存储整数，小数或字符。</p>
<h3 id="定义变量">定义变量</h3>
<p>Python 中的变量赋值不需要类型声明。</p>
<p>每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。</p>
<p>每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p>
<p>等号（=）用来给变量赋值。</p>
<p>等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值</p>
<pre><code class="language-py">#!/usr/bin/python
#-*- coding: UTF-8 -*-

counter = 100 # 赋值整型变量
miles = 1000.0 # 浮点型
name = &quot;John&quot; # 字符串

print counter
print miles
print name
</code></pre>
<p>好奇的你可能会发现，上面有两行注释：</p>
<pre><code class="language-py">#!/usr/bin/python
#-*- coding: UTF-8 -*-
</code></pre>
<p>第一行注释是为了告诉 <code>LINUX/UNIX</code> 去这个路径找到 python 的翻译器，这个注释必须放在文件首行。</p>
<p>第二行注释是说明如何解释字符串的编码，当你的 python 源文件中出现中文的时候你必须声明一下编码。</p>
<p>为了避免不必要的麻烦，所以一般情况下我们默认添加上面两行注释给系统和编译器看。</p>
<h3 id="python-标准数据类型">Python 标准数据类型</h3>
<ul>
<li>Number（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元祖）</li>
<li>Dictionary（字典）</li>
</ul>
<h4 id="number数字">Number（数字）</h4>
<ul>
<li>int (有符号整型）</li>
<li>long（长整型）</li>
<li>float（浮点型）</li>
<li>complex（具有实部和虚部的复数）</li>
</ul>
<p>除了 int 和 float，Python也支持其他类型的数字，例如 Decimal（高精度） 或者 Fraction（分数）。</p>
<h4 id="string字符串">String（字符串）</h4>
<p>字符串或串 (String) 是由数字、字母、下划线组成的一串字符。</p>
<p>在Python中字符串有三种表示方法:</p>
<p><a href="https://dp2px.com/post/python-jichu/image6"><img src="https://dp2px.com/post/python-jichu/image6" alt="Python 中表示字符串的三种方式" loading="lazy"></a>Python 中表示字符串的三种方式</p>
<p>关于字符串的一些拼接，截断，比较等方法这里就不列出了。可以去查 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#string-methods">字符串方法 API</a>.</p>
<h4 id="list列表">List（列表）</h4>
<p>Python 中可以通过组合一些值得到多种 <strong>复合</strong> 数据类型。其中最常用的列表 ，可以通过方括号括起、逗号分隔的一组值得到。一个列表<strong>可以包含不同类型的元素</strong>，但通常使用时各个元素类型相同。</p>
<pre><code class="language-py">#!/usr/bin/python
# -*- coding: UTF-8 -*-

list = [ 'abcd', 786 , 2.23, 'john', 70.2 ]
tinylist = [123, 'john']

print(list) # 输出完整列表
print(list[0]) # 输出列表的第一个元素
print(list[-1]) # 输出列表的最后一个元素
print(list[1:3]) # 输出第二个至第三个的元素
print(list[2:]) # 输出从第三个开始至列表末尾的所有元素
print(tinylist * 2) # 输出列表两次
print(list + tinylist) # 打印组合的列表
</code></pre>
<p>输出结果（注：加号 <code>+</code> 是列表连接运算符，星号 <code>*</code> 是重复操作）</p>
<pre><code class="language-py">['abcd', 786, 2.23, 'john', 70.2]
abcd
70.2
[786, 2.23]
[2.23, 'john', 70.2]
[123, 'john', 123, 'john']
['abcd', 786, 2.23, 'john', 70.2, 123, 'john']
</code></pre>
<h4 id="tuple元组">Tuple(元组）</h4>
<p>元组是另一个数据类型，类似于List（列表）。</p>
<p>元组用 <code>()</code> 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。</p>
<pre><code class="language-py">#!/usr/bin/python
# -*- coding: UTF-8 -*-

tuple = ( 'abcd', 786 , 2.23, 'john', 70.2 )
tinytuple = (123, 'john')

print(tuple) # 输出完整元组
print(tuple[0]) # 输出元组的第一个元素
print(tuple[-1]) # 输出列表的最后一个元素
print(tuple[1:3]) # 输出第二个至第三个的元素
print(tuple[2:]) # 输出从第三个开始至列表末尾的所有元素
print(tinytuple * 2) # 输出元组两次
print(tuple + tinytuple) # 打印组合的元组
</code></pre>
<p>输出结果:</p>
<pre><code class="language-shell">('abcd', 786, 2.23, 'john', 70.2)
abcd
70.2
(786, 2.23)
(2.23, 'john', 70.2)
(123, 'john', 123, 'john')
('abcd', 786, 2.23, 'john', 70.2, 123, 'john')
</code></pre>
<p>内置函数 <code>len()</code> 也可以作用到列表和元组上：</p>
<pre><code class="language-py">#!/usr/bin/python
# -*- coding: UTF-8 -*-

tinylist = [123, 'john']
tuple = ( 'abcd', 786 , 2.23, 'john', 70.2 )

print(len(tinylist))
print(len(tuple))
</code></pre>
<p>返回结果：</p>
<pre><code class="language-shell">2
5
</code></pre>
<p>除了上面的 <code>len()</code> 函数外，对于列表和元组还可以使用如下内置函数：</p>
<ul>
<li><code>cmp(tuple1, tuple2)</code> 比较两个元组元素。</li>
<li><code>max(tuple)</code> 返回元组中元素最大值。</li>
<li><code>min(tuple)</code> 返回元组中元素最小值。</li>
<li><code>tuple(seq)</code> 将列表转换为元组。</li>
</ul>
<p>当然，数组和元组也可以嵌套使用，可以成为二位数组甚至三维数组。</p>
<pre><code class="language-py">#!/usr/bin/python
# -*- coding: UTF-8 -*-

list1 = [123, 'john']
tuple1 = ( 'abcd', 786 , 2.23, 'john', 70.2 )

list2 = [234, 'xiaoqiang']
tuple2 = ('dlc', 444)

list3 = ['sxdlc', tuple2, list2]
tuple3 = ('ddllcc', list1, tuple1)

print(list3)
print(tuple3)
</code></pre>
<p>返回结果：</p>
<pre><code class="language-shell">['sxdlc', ('dlc', 444), [234, 'xiaoqiang']]
('ddllcc', [123, 'john'], ('abcd', 786, 2.23, 'john', 70.2))
</code></pre>
<h4 id="dictionary字典">Dictionary(字典）</h4>
<p>字典 (dictionary) 是除列表以外 python 之中最灵活的内置数据结构类型。列表是有序的对象结合，字典是无序的对象集合。</p>
<p>两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p>
<p>字典用 <code>{ }</code> 标识。字典由索引 (key) 和它对应的值 value 组成。</p>
<pre><code class="language-py">#!/usr/bin/python
# -*- coding: UTF-8 -*-

dict = {}
dict['one'] = &quot;This is one&quot;
dict[2] = &quot;This is two&quot;

tinydict = {'name': 'john','code':6734, 'dept': 'sales'}

print(dict['one']) # 输出键为'one' 的值
print(dict[2]) # 输出键为 2 的值
print(tinydict) # 输出完整的字典
print(tinydict.keys()) # 输出所有键
print(tinydict.values()) # 输出所有值
</code></pre>
<p>输出结果:</p>
<pre><code class="language-shell">This is one
This is two
{'name': 'john', 'code': 6734, 'dept': 'sales'}
dict_keys(['name', 'code', 'dept'])
dict_values(['john', 6734, 'sales'])
</code></pre>
<h3 id="python-数据类型转换">Python 数据类型转换</h3>
<p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">int(x [,base])</td>
<td style="text-align:left">将x转换为一个整数</td>
</tr>
<tr>
<td style="text-align:left">long(x [,base] )</td>
<td style="text-align:left">将x转换为一个长整数</td>
</tr>
<tr>
<td style="text-align:left">float(x)</td>
<td style="text-align:left">将x转换到一个浮点数</td>
</tr>
<tr>
<td style="text-align:left">complex(real [,imag])</td>
<td style="text-align:left">创建一个复数</td>
</tr>
<tr>
<td style="text-align:left">str(x)</td>
<td style="text-align:left">将对象 x 转换为字符串</td>
</tr>
<tr>
<td style="text-align:left">repr(x)</td>
<td style="text-align:left">将对象 x 转换为表达式字符串</td>
</tr>
<tr>
<td style="text-align:left">eval(str)</td>
<td style="text-align:left">用来计算在字符串中的有效Python表达式,并返回一个对象</td>
</tr>
<tr>
<td style="text-align:left">tuple(s)</td>
<td style="text-align:left">将序列 s 转换为一个元组</td>
</tr>
<tr>
<td style="text-align:left">list(s)</td>
<td style="text-align:left">将序列 s 转换为一个列表</td>
</tr>
<tr>
<td style="text-align:left">set(s)</td>
<td style="text-align:left">转换为可变集合</td>
</tr>
<tr>
<td style="text-align:left">dict(d)</td>
<td style="text-align:left">创建一个字典。d 必须是一个序列 (key,value)元组。</td>
</tr>
<tr>
<td style="text-align:left">frozenset(s)</td>
<td style="text-align:left">转换为不可变集合</td>
</tr>
<tr>
<td style="text-align:left">chr(x)</td>
<td style="text-align:left">将一个整数转换为一个字符</td>
</tr>
<tr>
<td style="text-align:left">unichr(x)</td>
<td style="text-align:left">将一个整数转换为Unicode字符</td>
</tr>
<tr>
<td style="text-align:left">ord(x)</td>
<td style="text-align:left">将一个字符转换为它的整数值</td>
</tr>
<tr>
<td style="text-align:left">hex(x)</td>
<td style="text-align:left">将一个整数转换为一个十六进制字符串</td>
</tr>
<tr>
<td style="text-align:left">oct(x)</td>
<td style="text-align:left">将一个整数转换为一个八进制字符串</td>
</tr>
</tbody>
</table>
<h2 id="python-控制流程">Python 控制流程</h2>
<h3 id="条件语句">条件语句</h3>
<pre><code class="language-py">if 判断条件1:
    执行语句1……
elif 判断条件2:
    执行语句2……
elif 判断条件3:
    执行语句3……
else:
    执行语句4……
</code></pre>
<p>Python 要求严格的代码缩进，以 Tab 键或者 4 个空格进行缩进，不像 java 和 js 这种语言一样用小括号来界定执行体，而是使用 <code>:</code> 和缩进来界定。</p>
<p>if 语句的判断条件可以用 <code>&gt;</code>（大于）、<code>&lt;</code>(小于)、<code>==</code>（等于）、<code>&gt;=</code>（大于等于）、<code>&lt;=</code>（小于等于）来表示其关系。</p>
<p>由于 python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现，如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功。</p>
<pre><code class="language-py">#!/usr/bin/python
# -*- coding: UTF-8 -*-

#if语句多个条件

num = 12
if num &gt;= 0 and num &lt;= 10:    # 判断值是否在0~10之间
    print ('[0---10]')
elif num &lt; 20 or num &gt; 10:    # 判断值是否在小于0或大于10
    print ('(10---20)')
else:
    print ('&gt;=20')


# 判断值是否在0~5或者10~15之间
if (num &gt;= 0 and num &lt;= 5) or (num &gt;= 10 and num &lt;= 15):   
    print ('hello')
else:
    print ('undefine')
</code></pre>
<p>针对前端开发的小朋友，我们来特别看一个示例代码：</p>
<pre><code class="language-py">#!/usr/bin/python
# -*- coding: UTF-8 -*-

num = 1
str = &quot;1&quot;

if num == str:
    print('num == str')
#elif num === str:  这是js语法，python中不存在
#    print('num === str')
else:
    print('not equal')
</code></pre>
<p>在 JavaScript 中有一个 <code>===</code> 来表示判断类型的严格相等，而 <code>==</code> 是会自动类型转换的抽象相等，需要注意的是在 Python 中的 <code>==</code> 就是严格相等，这个和 Java/C++ 等这种语言一致。</p>
<p>按照 python 中的语法，修改如下：</p>
<pre><code class="language-py">#!/usr/bin/python
# -*- coding: UTF-8 -*-

num = 1
str = &quot;1&quot;

if num == str:
    print('num == str')
elif num == int(str):  
    print('num === str')
else:
    print('not equal')
</code></pre>
<h3 id="for-循环">for 循环</h3>
<pre><code class="language-py">#!/usr/bin/python
# -*- coding: UTF-8 -*-

computerLanguage = ['Java', 'C', 'C++', 'PHP', 'Python', 'Go', 'Swift', 'Object-C']

for language in computerLanguage:
    print(language)
</code></pre>
<h3 id="while-循环">while 循环</h3>
<pre><code class="language-py">#!/usr/bin/python
# -*- coding: UTF-8 -*-

i = 10;
while i &gt; 0:
    print(i)
    i = i - 1
</code></pre>
<h3 id="循环使用-else-语句">循环使用 else 语句</h3>
<p>相对于我们熟知的 Java 和 JavaScript 这种语言，这个特性是 Python 所特有的，在 Java 中要实现这种逻辑我们往往需要添加一个额外的变量来记录结果，在 Python 中不需要。</p>
<p>while 语句中使用：</p>
<pre><code class="language-py">#!/usr/bin/python
# -*- coding: UTF-8 -*-

i = 10;
while(i &gt; 0):
    print(i)
    i = i - 1
else:
    print(&quot;&lt;= 0&quot;)
</code></pre>
<p>for 语句中使用：</p>
<pre><code class="language-py">#!/usr/bin/python
# -*- coding: UTF-8 -*-

computerLanguage = ['Java', 'C', 'C++', 'PHP', 'Python', 'Go', 'Swift', 'Object-C']

for language in computerLanguage:
    print(language)
else:
    print(&quot;OtherLanguage&quot;)
</code></pre>
<p>break (跳出循环）, continue（跳过本次循环）, pass（ 不做任何事情，一般用做占位语句）</p>
<h2 id="函数">函数</h2>
<p>函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。</p>
<p>函数能提高应用的模块性，和代码的重复利用率。</p>
<pre><code class="language-py">def functionname( parameters ):
   &quot;函数_文档字符串&quot;
   function_suite
   return [expression]
</code></pre>
<p>函数中的关键字参数和缺省参数。</p>
<pre><code class="language-py">#!/usr/bin/python
# -*- coding: UTF-8 -*-

#可写函数说明
def printinfo( name, age = 35 ):
   &quot;打印任何传入的字符串&quot;
   print &quot;Name: &quot;, name;
   print &quot;Age &quot;, age;
   return;

#调用printinfo函数
printinfo( age=50, name=&quot;miki&quot; );
printinfo( name=&quot;miki&quot; );
</code></pre>
<p>函数中的不定长参数（不是很常用）：</p>
<pre><code class="language-py">#!/usr/bin/python
# -*- coding: UTF-8 -*-

# 可写函数说明
def printinfo( arg1, *vartuple ):
   &quot;打印任何传入的参数&quot;
   print &quot;输出: &quot;
   print arg1
   for var in vartuple:
      print var
   return;

# 调用printinfo 函数
printinfo( 10 );
printinfo( 70, 60, 50 );
</code></pre>
<p>当然了，Python 的函数也可以携带返回值，而且可以携带多个返回值。</p>
<pre><code class="language-py">#!/usr/bin/python
# -*- coding: UTF-8 -*-

def firstvalue(a,b):
    c = a + b
    return c

print(firstvalue(1, 2))
</code></pre>
<p>返回多个值：</p>
<pre><code class="language-py">#!/usr/bin/python
# -*- coding: UTF-8 -*-

def secondvalue(a,b):
    c = a + b
    return (a,b,c)

x, y, z = secondvalue(1,2)

print('x:', x, 'y:', y, 'z:', z)
</code></pre>
<h2 id="python-面向对象">Python 面向对象</h2>
<h3 id="理解面向对象编程">理解面向对象编程</h3>
<p><strong>万事万物皆对象</strong></p>
<p>我们从窗户向外望去：每棵树：每一课树都可以看成一个对象。路上每个人：每一个人也可以看成一个对象。每个人上班的事件： 可以看成一个对象。</p>
<p><strong>类和对象</strong></p>
<p>类则是从某一部分对象中抽象出来的一个群体，这些群体具有某些共同的特征，我们可以根据我们所需的某几个特征抽象出我们自己想要的类。</p>
<p>每个人都是对象，我们可以抽象出来人的共同特征，就像我们给自然界的物质分类一样（如何分类？根据特征分类）。</p>
<p>每个人上班的事件是对象，我们可以抽象出来上班，上班和上课就是两个类。</p>
<h3 id="创建-python-中的类和对象">创建 Python 中的类和对象</h3>
<p>创建一个 Person 类：</p>
<pre><code class="language-py">class Person:

    #特殊方法，构造函数，创建这个类的时候会首先调用
    def __init__(self, name, age):
        self.name = name
        self.age = age

    #定义一个方法，显示人的信息
    def displyPersonInfor(self):
        print(&quot;name:&quot;, self.name, &quot;,  age:&quot;, self.age)
</code></pre>
<p>创建对象（对象就是类的具体实例）：</p>
<pre><code class="language-py">person = Person(&quot;xiaoming&quot;, 22)
</code></pre>
<p>访问属性及方法:</p>
<pre><code class="language-py">person.displyPersonInfor()  #访问类的成员方法

print(person.name)          #访问类的属性
print(person.age)
</code></pre>
<h3 id="python-对象销毁垃圾回收">python 对象销毁（垃圾回收）</h3>
<p>析构函数 del ，del 在对象销毁的时候被调用，当对象不再被使用时，del 方法运行：</p>
<pre><code class="language-py">#!/usr/bin/python
# -*- coding: UTF-8 -*-

class Person:

    #特殊方法，构造函数，创建这个类的时候会首先调用
    def __init__(self, name, age):
        self.name = name
        self.age = age

    #定义一个方法，显示人的信息
    def displyPersonInfor(self):
        print(&quot;name:&quot;, self.name, &quot;,  age:&quot;, self.age)

    #析构函数，对象销毁的时候调用
    def __del__(self):
        print(self.__class__.__name__ + &quot;销毁&quot;)


xiaoming = Person(&quot;xiaoming&quot;, 22)
xiaoming.displyPersonInfor()  #访问类的成员方法

xiaoqiang = Person(&quot;xiaoqiang&quot;, 25)
xiaoqiang.displyPersonInfor()

del xiaoming
del xiaoqiang
</code></pre>
<p>这里的 <code>del</code> 属于 python 的关键字，<code>del</code> 删除的是变量，而不是数据，解除了变量和数据的联系，例如：</p>
<pre><code class="language-py">#!/usr/bin/python
# -*- coding: UTF-8 -*-

a = 1
b = a
del a

print('b = ', b)
print('a = ', a)
</code></pre>
<p>打印结果：</p>
<pre><code class="language-shell">b =  1
Traceback (most recent call last):
  File &quot;C:/Users/Administrator/Desktop/test.py&quot;, line 9, in &lt;module&gt;
    print('a = ', a)
NameError: name 'a' is not defined
</code></pre>
<p>使用 <code>del</code> 解除这种引用关系之后， Python 是自带垃圾回收的，会自动回收内存，所以你不必担心。</p>
<h3 id="类的继承">类的继承</h3>
<p>面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。继承完全可以理解成类之间的类型和子类型关系。</p>
<p>继承语法 <code>class 派生类名（基类名）：</code> 基类名写作括号里，基本类是在类定义的时候，在元组之中指明的。</p>
<pre><code class="language-py">#!/usr/bin/python
# -*- coding: UTF-8 -*-

class Person:

    #特殊方法，构造函数，创建这个类的时候会首先调用
    def __init__(self, name, age):
        self.name = name
        self.age = age

    #定义一个方法，显示人的信息
    def displyPersonInfor(self):
        print(&quot;name:&quot;, self.name, &quot;,  age:&quot;, self.age)

    #析构函数，对象销毁的时候调用
    def __del__(self):
        print(self.__class__.__name__ + &quot;销毁&quot;)


class Student(Person):

    def __init__(self, name, age, grade):
        Person.__init__(self, name, age)
        self.grade = grade

    def displyPersonInfor(self):
        print(&quot;i am a student, my name is &quot; + self.name)


    def __del__(self):
        print(&quot;student析构函数调用&quot;)


xiaoming = Person(&quot;xiaoming&quot;, 22)
xiaoming.displyPersonInfor()  #访问类的成员方法

xiaoqiang = Student(&quot;xiaoqiang&quot;, 25, 3)
xiaoqiang.displyPersonInfor()

del xiaoming
del xiaoqiang
</code></pre>
<p>我们都知道面向对象的四大特性：抽象、继承、封装、多态。上面已经完美的体现出了抽象、继承、和封装，那么多态是什么呢？多态是面向对象中继承带来的第二大好处，这个好处可以极大的提高我们的代码耦合度和可维护性，让我们面向抽象编程而不是具体的实现。</p>
<h2 id="爬虫介绍">爬虫介绍</h2>
<p>说起爬虫应该大部分人都听过，这个东西入门很容易，但是随着学习的深入坑也是很深的，爬虫说白了就是抓取网页数据，我们先来看看一个纯静态的网页的抓取过程。</p>
<p>首先，我们安装一个 requests 模块，通过 <code>pip</code> 安装：</p>
<pre><code class="language-shell">pip install requests
</code></pre>
<figure data-type="image" tabindex="2"><a href="https://dp2px.com/post/python-jichu/image7.png"><img src="https://dp2px.com/post/python-jichu/image7.png" alt="img" loading="lazy"></a></figure>
<p>我们编写一个最简单的爬虫，爬取我网站上的一个简单页面，代码如下：</p>
<pre><code class="language-py">#!/usr/bin/python
# -*- coding: UTF-8 -*-

import requests

r = requests.get('https://dp2px.com/demo/image-alert/')

print('文本编码:', r.encoding)
print('响应状态码:', r.status_code)
print('字符串方式的响应体:', r.text)
</code></pre>
<p>没错，这就是最简单的爬虫了，我们后面将介绍如何去爬取复杂的页面并解析里面的有效数据。</p>

      </div>
      <div class="entry-block">
        <div class="entry-tags">
          
            <a href="https://xiong-zh.github.io/yaI-h-rVLi/">
              Python
            </a>
          
        </div>
      </div>
    </article>
    
      <section class="post-section prev-post">
        <div class="inner">
          <h3>前一篇</h3>
          <a href="https://xiong-zh.github.io/Python为什么现在这么火/">
            <strong>Python为什么现在这么火</strong>
          </a>
        </div>
      </section>
    
    
      <section class="post-section prev-post">
        <div class="inner">
          <h3>后一篇</h3>
          <a href="https://xiong-zh.github.io/常用Linux命令/">
            <strong>常用Linux命令</strong>
          </a>
        </div>
      </section>
    

    
      
        <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '7691fdf5a3780e9bb3a4',
    clientSecret: 'f4bd6c2287489e6b24a18af94afd54efcd0f55f9',
    repo: 'xiong-zh.github.io',
    owner: 'xiong-zh',
    admin: ['xiong-zh'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

      

      
    

    <footer class="footer">
  <div class="main">
    <a href="https://xiong-zh.github.io">
      <img class="avatar" src="https://xiong-zh.github.io/images/avatar.png?v=1583041260308" alt="ZhangXiong">
    </a>
    <div class="footer__social">
      
        
          <a href="https://github.com/xiong-zh" target="_blank"><i class="remixicon-github-line"></i></a>
        
      
        
          <a href="https://twitter.com/imzhangxiong" target="_blank"><i class="remixicon-twitter-line"></i></a>
        
      
        
          <a href="https://weibo.com/zhangxiongblog" target="_blank"><i class="remixicon-weibo-line"></i></a>
        
      
        
          <a href="https://www.zhihu.com/people/yisyxi" target="_blank"><i class="remixicon-zhihu-line"></i></a>
        
      
        
          <a href="https://www.facebook.com/xiong.zh.397" target="_blank"><i class="remixicon-facebook-line"></i></a>
        
      
        
      
        
      
        
          <a href="https://www.instagram.com/imzhangxiong/" target="_blank"><i class="remixicon-instagram-line"></i></a>
        
      
        
      
        
      
    </div>
    <p class="footer__sosumi">
      <a href="http://beian.miit.gov.cn/" target="_blank">滇ICP备20001109号</a> | Copyright © 2020 <a href="https://zhangxiong.net/" target="_blank">｜zhangxiong </a> All Right Reserved.
    </p>
    <a class="footer-rss" href="https://xiong-zh.github.io/atom.xml">RSS</a>
  </div>
</footer>

<script src="https://xiong-zh.github.io/media/prism.js"></script>
<script>
  Prism.highlightAll()
</script>

  </body>
</html>
