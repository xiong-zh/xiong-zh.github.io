<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiong-zh.github.io</id>
    <title>张雄</title>
    <updated>2020-01-20T06:48:45.455Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiong-zh.github.io"/>
    <link rel="self" href="https://xiong-zh.github.io/atom.xml"/>
    <subtitle>凡心所向,素履所往。生如逆旅，一苇以航。</subtitle>
    <logo>https://xiong-zh.github.io/images/avatar.png</logo>
    <icon>https://xiong-zh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 张雄</rights>
    <entry>
        <title type="html"><![CDATA[Python面试题归纳]]></title>
        <id>https://xiong-zh.github.io/post/Python 110面试题归纳</id>
        <link href="https://xiong-zh.github.io/post/Python 110面试题归纳">
        </link>
        <updated>2020-01-20T05:14:59.000Z</updated>
        <summary type="html"><![CDATA[<p>提高 python 运行效率的方法：<br>
1、使用生成器，因为可以节约大量内存<br>
2、循环代码优化，避免过多重复代码的执行<br>
3、核心模块用Cython  PyPy等，提高效率<br>
4、多进程、多线程、协程<br>
5、多个if elif条件判断，可以把最有可能先发生的条件放到前面写，这样可以减少程序判断的次数，提高效率</p>
]]></summary>
        <content type="html"><![CDATA[<p>提高 python 运行效率的方法：<br>
1、使用生成器，因为可以节约大量内存<br>
2、循环代码优化，避免过多重复代码的执行<br>
3、核心模块用Cython  PyPy等，提高效率<br>
4、多进程、多线程、协程<br>
5、多个if elif条件判断，可以把最有可能先发生的条件放到前面写，这样可以减少程序判断的次数，提高效率</p>
<!--more-->
<h2 id="110-道-python-面试笔试题汇总">110 道 Python 面试笔试题汇总</h2>
<p>一行代码实现 1--100 之和</p>
<pre><code>sum(range(0, 101))  # 5050
</code></pre>
<p>如何在一个函数内部修改全局变量</p>
<pre><code>num = 5
def func():
    global num
    num = 4
func()
print(num)  # 4
</code></pre>
<p>列出 5 个常用 Python 标准库？</p>
<pre><code>os：提供了不少与操作系统相关联的函数
sys：通常用于命令行参数
re：正则匹配
math：数学运算
datetime：处理日期时间
</code></pre>
<p>如何合并两个字典？</p>
<pre><code>    name = {'name': 'Gage'}
    age = {'age': 25}
    name.update(age)
    print(name)  # {'name': 'Gage', 'age': 25}
</code></pre>
<p>谈下 Python 的 GIL？</p>
<blockquote>
<p>GIL 是 Python 的全局解释器锁，同一进程中假如有多个线程运行，一个线程在运行 Python 程序的时候会占用 Python 解释器（加了一把锁即 GIL），使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行。</p>
</blockquote>
<p>多进程中因为每个进程都能被系统分配资源，相当于每个进程有了一个 Python 解释器，所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大。</p>
<p>Python 实现列表去重的方法？</p>
<pre><code>    num_list = [1, 3, 1, 5, 3, 6, 1]
    print([num for num in set(num_list)])  # [1, 3, 5, 6]
</code></pre>
<p>fun(args,kwargs)中的args, kwargs 什么意思？</p>
<blockquote>
<p>如果你有其他语言基础的话，你应该听说过重载的概念，对，Python 为了避免这种繁琐的情况发生，引入了 args 和 kwargs；args 用来接受非键值对的数据，即元组类型，而 kwargs 则用来接受键值对数据，即字典类型。</p>
</blockquote>
<p>Python2 和 Python3 的 range（100）的区别？</p>
<pre><code>Python2 返回列表，Python3 返回迭代器，节约内存。
</code></pre>
<p>生成一个 16 位的随机字符串？</p>
<pre><code>    import string
    print(''.join((random.choice(string.printable)) for i in range(16)))   # X{|op?_gSM-ra%N\  
</code></pre>
<p>一句话解释什么样的语言能够用装饰器?</p>
<pre><code> 函数可以作为参数传递
</code></pre>
<p>Python 内建数据类型有哪些？</p>
<pre><code>整型--int
布尔型--bool
字符串--str
列表--list
元组--tuple
字典--dict
</code></pre>
<p>简述面向对象中<strong>new</strong>和<strong>init</strong>区别？</p>
<pre><code>    1、__new__至少要有一个参数 cls，代表当前类，此参数在实例化时由Python解释器自动识别。
    2、__new__必须要有返回值，返回实例化出来的实例，这点在自己实现__new__时要特别注意，可以 return 父类（通过 super(当前类名, cls)）__new__出来的实例，或者直接是 object 的__new__出来的实例。
    3、__init__有一个参数 self，就是这个__new__返回的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值。
    4、如果__new__创建的是当前类的实例，会自动调用__init__函数，通过 return 语句里面调用的__new__函数的第一个参数是 cls 来保证是当前类实例，如果是其他类的类名，；那么实际创建返回的就是其他类的实例，其实就不会调用当前类的__init__函数，也不会调用其他类的__init__函数。
</code></pre>
<p>简述 with 方法打开处理文件帮我我们做了什么？</p>
<pre><code>打开文件在进行读写的时候可能会出现一些异常状况，如果按照常规的f.open 写法，我们需要 try,except,finally，做异常判断，并且文件最终不管遇到什么情况，都要执行 finally f.close() 关闭文件，with 方法帮我们实现了 finally 中 f.close。
</code></pre>
<p>列表[1,2,3,4,5]，请使用 map() 函数输出[1,4,9,16,25]，并使用列表推导式提取出大于 10 的数，最终输出 [16,25]？</p>
<pre><code>num_list = [1, 2, 3, 4, 5]
print([x for x in list(map(lambda x: x * x, num_list)) if x &gt; 10])  # [16,25]
</code></pre>
<p>python 中生成随机整数、随机小数、0--1 之间小数方法？</p>
<pre><code>import random
print(random.randint(1, 10))  # 随机整数
print(random.random())  # 0-1随机小数
print(random.uniform(2, 6)) # 指定范围[2-6]随机小数
</code></pre>
<p>避免转义给字符串加哪个字母表示原始字符串？</p>
<pre><code>    b'input\n' # bytes字节符，打印以b开头。
    输出：
    b'input\n'
    --------------------------------------
    r'input\n' # 非转义原生字符，经处理'\n'变成了'\\'和'n'。也就是\n表示的是两个字符，而不是换行。
    输出：
    'input\\n'
    --------------------------------------
    u'input\n' # unicode编码字符，python3默认字符串编码方式。
    输出：
    'input\n'
</code></pre>
<div class="nam">Python</div>，用正则匹配出标签里面的内容（“Python”），其中 class 的类名是不确定的。
```
    import re
    s = '<div class="nam">Python</div>'
    print(re.findall(r'<div class=".*">(.*?)</div>', s)) #['Python']
```
<p>Python 中断言方法举例？</p>
<pre><code>    age = 10
    assert 0 &lt; age &lt; 10
    --------------------
    Traceback (most recent call last):
      File &quot;F:/MxOnline/110/exam.py&quot;, line 69, in &lt;module&gt;
        assert 0 &lt; age &lt; 10
    AssertionError
</code></pre>
<p>dict 中 fromkeys 的用法</p>
<pre><code>keys = ('info',)
print(dict.fromkeys(keys, ['Gage', '25', 'man'])) # {'info': ['Gage', '25', 'man']}
</code></pre>
<p>请用正则表达式输出汉字</p>
<pre><code>    import re
    a = &quot;not 404 found 中国 2018 我爱你&quot;
    r1 = '[a-zA-Z0-9’!&quot;#$%&amp;\'()*+,-./:;&lt;=&gt;?@，。?★、…【】《》？“”‘’！[\\]^_`{|}~]+\s?'
    print(re.sub(r1, '', a))  # 中国 我爱你
</code></pre>
<p>Python2 和 Python3 区别？列举 5 个</p>
<pre><code> 1.去除了&lt;&gt;，全部改用!=
 2.xrange() 改名为range()
 3.内存操作cStringIO改为StringIO
 4.加入nonlocal 作用：可以引用外层非全局变量
 5.zip()、map()和filter()都返回迭代器，而不是生成器，更加节约内存
</code></pre>
<p>列出 Python 中可变数据类型和不可变数据类型，为什么？</p>
<pre><code> 1、可变数据类型：list、dict、set
 2、不可变数据类型：int/float、str、tuple
 3、原理：可变数据类型即公用一个内存空间地址，不可变数据类型即每产生一个对象就会产生一个内存地址
</code></pre>
<p>dict 的内部实现？</p>
<blockquote>
<p>在 Python 中，字典是通过哈希表实现的。也就是说，字典是一个数组，而数组的索引是键经过哈希函数处理后得到的。哈希函数的目的是使键均匀地分布在数组中。由于不同的键可能具有相同的哈希值，即可能出现冲突，高级的哈希函数能够使冲突数目最小化。</p>
</blockquote>
<p>s = &quot;ajldjlajfdljfddd&quot;，去重并从小到大排序输出&quot;adfjl&quot;？</p>
<pre><code>s1 = &quot;ajldjlajfdljfddd&quot;
print(''.join(sorted(set(s1))))  # adfjl
</code></pre>
<p>用 lambda 函数实现两个数相乘？</p>
<pre><code>mul = lambda x, y: x*y
print(mul(2, 4))  # 8
</code></pre>
<p>字典根据键从小到大排序？</p>
<pre><code>    info = {'name': 'Gage', 'age': 25, 'sex': 'man'}
    print(sorted(info.items(), key=lambda x: x[0])) # [('age', 25), ('name', 'Gage'), ('sex', 'man')]
</code></pre>
<p>Python 获取当前日期？</p>
<pre><code>    import time
    import datetime
    print(datetime.datetime.now())
    print(time.strftime('%Y-%m-%d %H:%M:%S')) # 2019-03-13 11:33:56
</code></pre>
<p>获取请求头的参数？</p>
<pre><code>    from urllib.parse import urlparse, parse_qs
    s2 = &quot;/get_feed_list?version_name=5.0.9.0&amp;device_id=12242channel_name=google&quot;
    def spiltline(value):
        url = {'site': urlparse(value).path}
        url.update(parse_qs(urlparse(value).query))
        return url
     --------------------------------------
     {'site': '/get_feed_list', 'version_name': ['5.0.9.0'], 'device_id': ['12242channel_name=google']}
</code></pre>
<p>例举五条 PEP8 规范</p>
<pre><code>不要在行尾加分号, 也不要用分号将两条命令放在同一行
不要使用反斜杠连接行
不要在返回语句或条件语句中使用括号
顶级定义之间空2行, 方法定义之间空1行，顶级定义之间空两行
如果一个类不继承自其它类, 就显式的从object继承
</code></pre>
<p>Python 语言的运行机制</p>
<figure data-type="image" tabindex="1"><img src="https://images.gitbook.cn/4408a5a0-4484-11e9-bd1f-43448f7c081f" alt="PVM" loading="lazy"></figure>
<p>Fibonacci 数列</p>
<pre><code>    def fab(n):
        a, b = 0, 1
        while n:
            yield b
            a, b = b, a+b
            n -= 1
</code></pre>
<pre><code>
</code></pre>
<p>Python 三目运算</p>
<pre><code># 若果 a&gt;b 成立  就输出  a-b  否则 a+b
h = a-b if a&gt;b else a+b
</code></pre>
<p>单例模式</p>
<pre><code>     class Single(object):
        __isstance = None
        __first_init = False
        def __new__(cls, *args, **kwargs):
            if not cls.__isstance:
                cls.__isstance = object.__new__(cls)
            return cls.__isstance
        def __init__(self, name):
            if not self.__first_init:
                self.name = name
                Singleton.__first_init = True
</code></pre>
<p>正则匹配优先级</p>
<figure data-type="image" tabindex="2"><img src="https://images.gitbook.cn/e143ce80-4484-11e9-8cff-9373d208f277" alt="enter image description here" loading="lazy"></figure>
<p>递归</p>
<pre><code>     def digui(n):
        if n == 1:
            return 1
        else:
            return (n * digui(n-1)
</code></pre>
<pre><code>
</code></pre>
<p>统计字符串每个单词出现的次数</p>
<pre><code>from collections import Counter
s3 = &quot;kjalfj;ldsjafl;hdsllfdhg;lahfbl;hl;ahlf;h&quot;
print(Counter(s3))
</code></pre>
<p>正则 re.complie 作用</p>
<blockquote>
<p>re.compile 是将正则表达式编译成一个对象，加快速度，并重复使用</p>
</blockquote>
<p>filter 方法求出列表所有奇数并构造新列表，a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p>
<pre><code>    a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    print(list(filter(lambda x: x % 2, a)))
    ---------------------
    Counter({'l': 9, ';': 6, 'h': 6, 'f': 5, 'a': 4, 'j': 3, 'd': 3, 's': 2, 'k': 1, 'g': 1, 'b': 1})
</code></pre>
<p>列表推导式求列表所有奇数并构造新列表，a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p>
<pre><code>    print([x for x in a if x % 2])
</code></pre>
<p>a=（1，）b=(1)，c=(&quot;1&quot;) 分别是什么类型的数据？</p>
<pre><code>    print(type((1, ))) # tuple
    print(type((1))) # int
    print(type((&quot;1&quot;))) # str
</code></pre>
<p>两个列表[1,5,7,9]和[2,2,6,8]合并为[1,2,2,3,6,7,8,9]</p>
<pre><code>l1 = [1, 5, 7, 9]
l2 = [2, 2, 6, 8]
l1.extend(l2)
</code></pre>
<p>用 python 删除文件和用 linux 命令删除文件方法</p>
<pre><code>python：os.remove(文件名)
linux: rm 文件名
</code></pre>
<p>logging 模块的使用？</p>
<pre><code>    import logging
    logging.basicConfig(level = logging.INFO,format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    logger = logging.getLogger(__name__)

    logger.info(&quot;Start print log&quot;)
    logger.debug(&quot;Do something&quot;)
    logger.warning(&quot;Something maybe fail.&quot;)
    logger.info(&quot;Finish&quot;)
</code></pre>
<p>写一段自定义异常代码</p>
<pre><code>    #自定义异常用raise抛出异常
    def fn():
        try:
            for i in range(5):
                if i&gt;2:
                    raise Exception(&quot;数字大于2了&quot;)
        except Exception as ret:
            print(ret)
    fn()    # 数字大于2了
</code></pre>
<p>正则表达式匹配中，（.<em>）和（.</em>?）匹配区别？</p>
<pre><code>    #（.*）是贪婪匹配，会把满足正则的尽可能多的往后匹配
    #（.*?）是非贪婪匹配，会把满足正则的尽可能少匹配
    s = &quot;&lt;a&gt;哈哈&lt;/a&gt;&lt;a&gt;呵呵&lt;/a&gt;&quot;
    import re
    res1 = re.findall(&quot;&lt;a&gt;(.*)&lt;/a&gt;&quot;, s)
    print(&quot;贪婪匹配&quot;, res1)
    res2 = re.findall(&quot;&lt;a&gt;(.*?)&lt;/a&gt;&quot;, s)
    print(&quot;非贪婪匹配&quot;, res2)
    -------------------------
    输出：
    贪婪匹配 ['哈哈&lt;/a&gt;&lt;a&gt;呵呵']
    非贪婪匹配 ['哈哈', '呵呵']
</code></pre>
<p>[[1,2],[3,4],[5,6]]一行代码展开该列表，得出[1,2,3,4,5,6]</p>
<pre><code>    a=[[1,2],[3,4],[5,6]]
    print([j for i in a for j in i])
</code></pre>
<p>x=&quot;abc&quot;,y=&quot;def&quot;,z=[&quot;d&quot;,&quot;e&quot;,&quot;f&quot;]，分别求出 x.join(y) 和 x.join(z) 返回的结果</p>
<pre><code>    #join()括号里面的是可迭代对象，x插入可迭代对象中间，形成字符串，结果一致
    x=&quot;abc&quot;
    y=&quot;def&quot;
    z=[&quot;d&quot;,&quot;e&quot;,&quot;f&quot;]
    a=x.join(y)
    b=x.join(z)
    print(a)
    print(b)
    均输出：
    dabceabcf
</code></pre>
<p>举例说明异常模块中 try except else finally 的相关意义</p>
<pre><code>    try..except..else没有捕获到异常，执行else语句
    try..except..finally不管是否捕获到异常，都执行finally语句
</code></pre>
<p>python 中交换两个数值</p>
<pre><code>a,b=1,2
a,b=b,a
</code></pre>
<p>举例说明 zip() 函数用法</p>
<pre><code>    list1 = [1, 2, 3, 5]
    list2 = [4, 5, 6]
    zipped = zip(list1, list2)
    print(list(zipped))  # [(1, 4), (2, 5), (3, 6)]
    # print(list(zip(*zipped)))  # [(1, 2, 3), (4, 5, 6)]
</code></pre>
<p>a=&quot;张明 98分&quot;，用 re.sub，将 98 替换为 100</p>
<pre><code>    import re
    a=&quot;张明 98分&quot;
    ret=re.sub(r&quot;\d+&quot;,&quot;100&quot;,a)
    print(ret)    
</code></pre>
<p>a=&quot;hello&quot;和b=&quot;你好&quot;编码成 bytes 类型</p>
<pre><code>    a=b&quot;hello&quot;        
    b=&quot;你好&quot;.encode()
    print(a,b)
    print(type(a),type(b))
</code></pre>
<p>[1,2,3]+[4,5,6]的结果是多少？</p>
<pre><code>print([1,2,3]+[4,5,6]) # [1, 2, 3, 4, 5, 6]
</code></pre>
<p>提高 python 运行效率的方法</p>
<pre><code>1、使用生成器，因为可以节约大量内存
2、循环代码优化，避免过多重复代码的执行
3、核心模块用Cython  PyPy等，提高效率
4、多进程、多线程、协程
5、多个if elif条件判断，可以把最有可能先发生的条件放到前面写，这样可以减少程序判断的次数，提高效率
</code></pre>
<p>遇到 bug 如何处理</p>
<pre><code>1、细节上的错误，通过print（）打印，能执行到print（）说明一般上面的代码没有问题，分段检测程序是否有问题，如果是js的话可以alert或console.log
2、如果涉及一些第三方框架，会去查官方文档或者一些技术博客。
3、对于bug的管理与归类总结，一般测试将测试出的bug用teambin等bug管理工具进行记录，然后我们会一条一条进行修改，修改的过程也是理解业务逻辑和提高自己编程逻辑缜密性的方法，我也都会收藏做一些笔记记录。
4、导包问题、城市定位多音字造成的显示错误问题
</code></pre>
<p>list=[2,3,5,4,9,6]，从小到大排序，不许用 sort，输出[2,3,4,5,6,9]</p>
<pre><code>    def quicksort(list):
        if len(list)&lt;2:
            return list
        else:
            midpivot = list[0]
            lessbeforemidpivot = [i for i in list[1:] if i&lt;=midpivot]
            biggerafterpivot = [i for i in list[1:] if i &gt; midpivot]
            finallylist = quicksort(lessbeforemidpivot)+[midpivot]+quicksort(biggerafterpivot)
            return finallylist

    print quicksort([2,3,5,4,9,6])
</code></pre>
<p>两数相除保留两位小数</p>
<pre><code>print(round(5/3, 2)) # 1.67
</code></pre>
<p>正则匹配，匹配日期 2018-03-20</p>
<pre><code>    import re
    print(re.findall('((?:(?:[2468][048]00|[13579][26]00|[1-9]\d0[48]|[1-9]\d[2468][048]|[1-9]\d[13579][26])/(?:0?2/(?:0[1-9]|0?[1-9](?=\D)|[12]\d)))|(?:(?:[12]\d{3})/(?:(?:0?2/(?:0[1-9]|0?[1-9](?=\D)|1\d|2[0-8]))|(?:0?[3578]/(?:0[1-9]|0?[1-9](?=\D)|[12]\d|3[01]))|(?:0?[469]/(?:0[1-9]|0?[1-9](?=\D)|[12]\d|30))|(?:1[02]/(?:0[1-9]|0?[1-9](?=\D)|[12]\d|3[01]))|(?:11/(?:0[1-9]|0?[1-9](?=\D)|[12]\d|30))|(?:0?1/(?:0[1-9]|0?[1-9](?=\D)|[12]\d|3[01])))))', 'Date：2018/03/20'))
</code></pre>
<p>使用 pop 和 del 删除字典中的&quot;name&quot;字段，dic={&quot;name&quot;:&quot;zs&quot;,&quot;age&quot;:18}</p>
<pre><code>dic = {&quot;name&quot;: &quot;zs&quot;, &quot;age&quot;: 18}
dic.pop('name')
del dic['age']
print(dic) # {}
</code></pre>
<p>简述多线程、多进程</p>
<pre><code>进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。
线程是程序执行时的最小单位，它是进程的一个执行流。
进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵
线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多
</code></pre>
<p>简述 any() 和 all() 方法</p>
<pre><code># all如果存在0 Null False返回False,否则返回True;any与之相反
print(all([0, 1, 2, 3]))
print(all([1, 2, 3]))
</code></pre>
<p>IOError、AttributeError、ImportError、IndentationError、IndexError、KeyError、SyntaxError、NameError 分别代表什么异常</p>
<pre><code>    IOError：输入输出异常
    AttributeError：试图访问一个对象没有的属性
    ImportError：无法引入模块或包，基本是路径问题
    IndentationError：语法错误，代码没有正确的对齐
    IndexError：下标索引超出序列边界
    KeyError:试图访问你字典里不存在的键
    SyntaxError:Python代码逻辑语法出错，不能执行
    NameError:使用一个还未赋予对象的变量
</code></pre>
<p>Python 中 copy 和 deepcopy 区别</p>
<pre><code>    # copy
    l1 = [1, 2, [3, 4]]
    l2 = copy.copy(l1)
    l1.append(5)
    l1[2].append(5)  # 子对象 改变
    print(l1)
    print(l2)
    --------------
    [1, 2, [3, 4, 5], 5]
    [1, 2, [3, 4, 5]]
    # deepcopy
    l1 = [1, 2, [3, 4]]
    l2 = copy.deepcopy(l1)
    l1.append(5)
    l1[2].append(5)
    print(l1)
    print(l2)
    --------------
    [1, 2, [3, 4, 5], 5]
    [1, 2, [3, 4]]
</code></pre>
<p>列出几种魔法方法并简要介绍用途</p>
<pre><code>__init__:对象初始化方法
__new__:创建对象时候执行的方法，单列模式会用到
__str__:当使用print输出对象的时候，只要自己定义了__str__(self)方法，那么就会打印从在这个方法中return的数据
__del__:删除对象执行的方法
</code></pre>
<p>上下文管理器 with...as 的实现</p>
<pre><code>    class Close():
        def __init__(self, obj):
            self.obj = obj

        def __enter__(self):
            return self.obj  # 返回作为as目标

        def __exit__(self, exc_type, exc_val, exc_tb):
            try:
                self.obj.close()
            except AttributeError:
                print(exc_type)
</code></pre>
<p>python arg.py 1 2 命令行启动程序并传参，print(sys.argv) 会输出什么数据？</p>
<pre><code>['arg.py', '1', '2']
</code></pre>
<p>请将[i for i in range(3)]改成生成器</p>
<pre><code>    class iter():
        def __init__(self, data):
            self.data = data
            self.loop = -1
        def __iter__(self):
            return self
        def __next__(self):
            if self.loop &gt;= self.data:
                raise StopIteration
            self.loop += 1
            return self.loop
</code></pre>
<p>字符串转化大小写？</p>
<pre><code>str=&quot;HHaa&quot;
print(str.upper())
print(str.lower())
</code></pre>
<p>请说明 sort 和 sorted 对列表排序的区别</p>
<pre><code>1.sort()与sorted()的不同在于，sort是在原位重新排列列表，而sorted()是产生一个新的列表。sorted(L)返回一个排序后的L，不改变原始的L；L.sort()是对原始的L进行操作，调用后原始的L会改变，没有返回值；所以a = a.sort()是错的啦！a = sorted(a)才对。
2.sorted()适用于任何可迭代容器，list.sort()仅支持list（本身就是list的一个方法）
3.基于以上两点，sorted使用频率比list.sort()更高些，所以Python中更高级的排序技巧便通过sorted()来演示
</code></pre>
<p>对 foo = [-5,8,0,4,9,-4,-20,-2,8,2,-4] 进行排序，使用 lambda 函数从小到大排序</p>
<pre><code>foo = [-5,8,0,4,9,-4,-20,-2,8,2,-4]
res=sorted(foo,key=lambda x:x)      
print(res)
</code></pre>
<p>在 70 题的基础上将正数从小到大，负数从大到小</p>
<pre><code>foo = [-5,8,0,4,9,-4,-20,-2,8,2,-4]
res=sorted(foo,key=lambda x:(x&lt;0,abs(x)))    
print(res)
</code></pre>
<p>Python 传参数是传值还是传址？</p>
<blockquote>
<p>Python 中函数参数是引用传递（注意不是值传递）。对于不可变类型（数值型、字符串、元组），因变量不能修改，所以运算不会影响到变量自身；而对于可变类型（列表字典）来说，函数体运算可能会更改传入的参数变量。</p>
</blockquote>
<p>w、w+、r、r+、rb、rb+ 文件打开模式区别</p>
<figure data-type="image" tabindex="3"><img src="https://images.gitbook.cn/89fca880-4539-11e9-b7cd-b595562b2f4a" alt="enter image description here" loading="lazy"></figure>
<p>int(&quot;1.4&quot;)、int(1.4)的输出结果？</p>
<pre><code>print(int(&quot;1.4&quot;))   # 异常
print(int(1.4)) # 1
</code></pre>
<p>Python 垃圾回收机制？</p>
<pre><code>    1.引用计数
    import sys
    # 请在Python解释器下运行  为 2  创建一次 调用一次
    str1 = 'hello world'
    print(sys.getrefcount(str1))
    2.分代技术
    Python默认定义了三代对象集合，索引数越大，对象存活时间越长
    Python中使用了某些启发式算法（heuristics）来加速垃圾回收。例如，越晚创建的对象更有可能被回收。对象被创建之后，垃圾回收器会分配它们所属的代（generation）。每个对象都会被分配一个代，而被分配更年轻代的对象是优先被处理的。
    3.引用循环
    垃圾回收器会定时寻找这个循环，并将其回收。举个例子，假设有两个对象o1和o2，而且符合o1.x == o2和o2.x == o1这两个条件。如果o1和o2没有其他代码引
</code></pre>
<p>Python 字典和 json 字符串相互转化方法</p>
<pre><code>    import json
    dic = {&quot;name&quot;:&quot;zs&quot;}
    res = json.dumps(dic)
    print(res,type(res))
    ret = json.loads(res)
    print(ret,type(ret))
</code></pre>
<p>Python 正则中 search 和 match 的区别</p>
<blockquote>
<p>match() 从第一个字符开始找, 如果第一个字符就不匹配就返回 None, 不继续匹配. 用于判断字符串开头或整个字符串是否匹配,速度快。 search() 会整个字符串查找,直到找到一个匹配。</p>
</blockquote>
<p>Python 中读取 Excel 文件的方法？</p>
<pre><code>import pandas
read_excel = pandas.read_excel(&quot;test.xlsx&quot;)
print(read_excel)
</code></pre>
<p>输入日期， 判断这一天是这一年的第几天？</p>
<pre><code>import datetime
def dayofyear():
    year = input(&quot;请输入年份: &quot;)
    month = input(&quot;请输入月份: &quot;)
    day = input(&quot;请输入天: &quot;)
    date1 = datetime.date(year=int(year),month=int(month),day=int(day))
    date2 = datetime.date(year=int(year),month=1,day=1)
    return (date1-date2).days+1
</code></pre>
<p>什么是 lambda 函数？有什么好处？</p>
<pre><code>    lambda 函数是一个可以接收任意多个参数(包括可选参数)并且返回单个表达式值的匿名函数

    好处：
    1、lambda 函数比较轻便，即用即删除，很适合需要完成一项功能，但是此功能只在此一处使用，
    连名字都很随意的情况下；
    2、匿名函数，一般用来给 filter， map 这样的函数式编程服务;
    3、作为回调函数，传递给某些应用，比如消息处理
</code></pre>
<p>求两个列表的交集、差集、并集？</p>
<pre><code>    a= [1,2,3,4]
    b= [4,3,5,6]
    jj1=[i for i in a if i in b]   #在a中的i，并且也在b中，就是交集
    jj2=list(set(a).intersection(set(b)))
    bj1=list(set(a).union(set(b)))
    cj1=list(set(b).difference(set(a)))
    cj2=list(set(a).difference(set(b)))
    print(&quot;交集&quot; ,jj1)
    print(&quot;交集&quot;,jj2)
    print(&quot;并集&quot;,bj1)
    print(&quot;差集&quot; ,cj1)
    print(&quot;差集&quot; ,cj2)
</code></pre>
<p>什么是负索引？</p>
<pre><code>与正索引不同，负索引是从右边开始检索
</code></pre>
<p>正则匹配不是以4和7结尾的手机号？</p>
<pre><code>    import re
    tels=[&quot;13100001234&quot;,&quot;18912344321&quot;,&quot;10086&quot;,&quot;18800007777&quot;]
    for tel in tels:
        ret=re.match(&quot;1\d{9}[0-3,5-6,8-9]&quot;,tel)
        if ret:
            print(&quot;结果是：&quot;,ret.group())
        else:
            print(&quot;%s不是想要的手机号&quot; % tel)
</code></pre>
<p>用两种方法去空格？</p>
<pre><code>    str=&quot;hello world ha ha&quot;
    res=str.replace(&quot; &quot;,&quot;&quot;)
    print(res)

    list=str.split(&quot; &quot;)
    res=&quot;&quot;.join(list)
    print(res)

    均输出：
    helloworldhaha
</code></pre>
<p>统计字符串中某字符出现次数？</p>
<pre><code>str=&quot;张三 哈哈 张三 呵呵 张三&quot;
res=str.count(&quot;张三&quot;)
print(res) 
</code></pre>
<p>正则表达式匹配 URL</p>
<pre><code>    import re
    pattern = re.compile(r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&amp;+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+')    # 匹配模式

    string = 'Its after 12 noon, do you know where your rooftops are? https://blog.gaozhe.top '
    url = re.findall(pattern,string)
    print(url)
</code></pre>
<p>正则匹配以 163.com 结尾的邮箱？</p>
<pre><code>    import re
    email_list= [&quot;sdgaozhe@163.com&quot;,&quot;xiaoWang@163.comheihei&quot;, &quot;.com.602556194g@qq.com&quot; ]
    for email in email_list:
        ret = re.match(&quot;[\w]{4,20}@163\.com$&quot;,email)
        if ret:
            print(&quot;%s 是符合规定的邮件地址，匹配后结果是:%s&quot; % (email,ret.group()))
        else:
            print(&quot;%s 不符合要求&quot; % email)
</code></pre>
<p><code>s=&quot;info:xiaoZhang 33 shandong&quot;</code>,用正则切分字符串输出<code>['info', 'xiaoZhang', '33', 'shandong']</code></p>
<pre><code>    import re
    s=&quot;info:xiaoZhang 33 shandong&quot;
    res=re.split(r&quot;:| &quot;,s)          #|表示或，根据冒号或者空格切分
    print(res)
</code></pre>
<p>两个有序列表，l1,l2，对这两个列表进行合并不可使用 extend</p>
<pre><code>    def loop_merge_sort(l1,l2):
        tmp = []
        while len(l1)&gt;0 and len(l2)&gt;0:
            if l1[0] &lt;l2[0]:
                tmp.append(l1[0])
                del l1[0]
            else:
                tmp.append(l2[0])
                del l2[0]
</code></pre>
<p>代码描述列表推导式、字典推导式、生成器？</p>
<pre><code>    import random
    td_list=[i for i in range(10)]
    print(&quot;列表推导式&quot;, td_list, type(td_list))
    ge_list = (i for i in range(10))
    print(&quot;生成器&quot;, ge_list)
    dic = {k:random.randint(4, 9)for k in [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]}
    print(&quot;字典推导式&quot;,dic,type(dic))
</code></pre>
<p>根据键对字典排序，不可使用zip？</p>
<pre><code>    dic = {&quot;name&quot;:&quot;zs&quot;,&quot;sex&quot;:&quot;man&quot; ,&quot;city&quot;:&quot;bj&quot;}
    print(dic.items())
    b= sorted(dic.items(),key= lambda x:x[0])
    print(&quot;根据键排序&quot;,b)
    new_dic = {i[0]:i[1] for i in b}
    print(&quot;字典推导式构造新字典&quot;,new_dic)
</code></pre>
<p>阅读一下代码他们的输出结果是什么？</p>
<pre><code>def multi():
    return [lambda x : i*x for i in range(4)]
print([m(3) for m in multi()])  # [9,9,9,9]
</code></pre>
<p>代码实现 Python 的线程同步</p>
<pre><code>    import threading 
    import time

    def thread():
        time.sleep(2)
        print('---子线程结束---')

    def main():
        t1 = threading.Thread(target=thread)
        t1.start()
        print('---主线程--结束')

    if __name__ =='__main__':
        main()
    #执行结果
    ---主线程--结束
    ---子线程结束---
</code></pre>
<p>简述 read、readline、readlines 的区别？</p>
<pre><code>read 读取整个文件
readline 读取下一行,使用生成器方法
readlines 读取整个文件到一个迭代器以供我们遍历
</code></pre>
<p>a = &quot; hehheh &quot;，去除收尾空格？</p>
<pre><code>a=&quot;  hehheh  &quot;
print(a.strip())
</code></pre>
<p>yield 用法</p>
<pre><code>yield 就是保存当前程序执行状态。你用 for 循环的时候，每次取一个元素的时候就会计算一次。用 yield 的函数叫 generator,和 iterator 一样，它的好处是不用一次计算所有元素，而是用一次算一次，可以节省很多空间，generator 每次计算需要上一次计算结果，所以用 yield,否则一 return，上次计算结果就没了。
</code></pre>
<p>字符串 &quot;123&quot; 转换成 123，不使用内置 API，例如 int()</p>
<pre><code>    def atoi(s):
        num = 0
        for v in s:
            t = &quot;%s * 1&quot; % v
            n = eval(t)
            num = num * 10 + n
        return num
</code></pre>
<p>is 和 == 的区别</p>
<pre><code>    # is 比较的是内存地址   == 比较内容和数据类型

    a = [1, 2, 3]
    b = a
    print(a is b)
    print(a == b)

    c = copy.deepcopy(a)
    print(a is c)
    print(a == c)
    -------------
    True
    True
    False
    True
</code></pre>
<p>有没有一个工具可以帮助查找 python 的 bug 和进行静态的代码分析？</p>
<blockquote>
<p>PyChecker 是一个 python 代码的静态分析工具，它可以帮助查找 python 代码的 bug，会对代码的复杂度和格式提出警告 Pylint 是另外一个工具可以进行 codingstandard 检查</p>
</blockquote>
<p>文件递归</p>
<pre><code>    def print_directory_contents(sPath):
    &quot;&quot;&quot;
    这个函数接收文件夹的名称作为输入参数
    返回该文件夹中文件的路径
    以及其包含文件夹中文件的路径
    &quot;&quot;&quot;
    import os
    for s_child in os.listdir(s_path):
        s_child_path = os.path.join(s_path, s_child)
        if os.path.isdir(s_child_path):
            print_directory_contents(s_child_path)
        else:
            print(s_child_path)
</code></pre>
<p>Python 如何 copy 一个文件？</p>
<blockquote>
<p>shutil 模块有一个 copyfile 函数可以实现文件拷贝</p>
</blockquote>
<p>打乱一个排好序的 list 对象 alist？</p>
<pre><code>    import random
    alist = [1,2,3,4,5]
    random.shuffle(alist)
    print(alist)
</code></pre>
<p>对 s=&quot;hello&quot;进行反转</p>
<pre><code>s=&quot;hello&quot;
print(s[::-1])
</code></pre>
<p>Python 中单下划线和双下划线使用</p>
<pre><code>__foo__:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突，就是例如__init__(),__del__(),__call__()这些特殊方法

_foo:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.不能用from module import * 导入，其他方面和公有一样访问；

__foo:这个有真正的意义:解析器用_classname__foo来代替这个名字,以区别和其他类相同的命名,它无法直接像公有成员一样随便访问,通过对象名._类名__xxx这样的方式可以访问.
</code></pre>
<p>反转一个整数</p>
<pre><code>    class Solution(object):
        def reverse(self,x):
            if -10&lt;x&lt;10:
                return x
            str_x = str(x)
            if str_x[0] !=&quot;-&quot;:
                str_x = str_x[::-1]
                x = int(str_x)
            else:
                str_x = str_x[1:][::-1]
                x = int(str_x)
                x = -x
            return x if -2147483648&lt;x&lt;2147483647 else 0
    if __name__ == '__main__':
        s = Solution()
        reverse_int = s.reverse(-120)
        print(reverse_int)
</code></pre>
<p>代码描述静态方法 (staticmethod)，类方法(classmethod) 和实例方法</p>
<pre><code>    def foo(x):
        print &quot;executing foo(%s)&quot;%(x)

    class A(object):
        def foo(self,x):
            print &quot;executing foo(%s,%s)&quot;%(self,x)

        @classmethod
        def class_foo(cls,x):
            print &quot;executing class_foo(%s,%s)&quot;%(cls,x)

        @staticmethod
        def static_foo(x):
            print &quot;executing static_foo(%s)&quot;%x

    a=A()
</code></pre>
<p>新式类和旧式类的区别？</p>
<pre><code>a. 在python里凡是继承了object的类，都是新式类
b. Python3里只有新式类
c. Python2里面继承object的是新式类，没有写父类的是经典类
d. 经典类目前在Python里基本没有应用
</code></pre>
<p>请写出一个在函数执行后输出日志的装饰器</p>
<pre><code>    def do_log(func):
        @wraps(func)
        def wrapper(*args, **kw):
            if func.__name__ == &quot;debug&quot;:
                msg = &quot;debug {}&quot;.format(args[0])
            elif func.__name__ == &quot;info&quot;:
                msg = &quot;info {}&quot;.format(args[0])
            else:
                msg =  &quot;unknown {}&quot;.format(args[0])
            return func(msg, **kw)
        return wrapper

    @do_log
    def debug(msg):
        print(msg)

    @do_log
    def info(msg):
        print(msg)

    if __name__ == &quot;__main__&quot;:
        debug(&quot;123&quot;)
        info(&quot;abc&quot;)
</code></pre>
<p>请解释一下协程的优点</p>
<pre><code>子程序切换不是线程切换，而是由程序自身控制
没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显
不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁
</code></pre>
<p>闭包必须满足那几点</p>
<pre><code>1.必须有一个内嵌函数
2.内嵌函数必须引用外部函数中的变量
3.外部函数的返回值必须是内嵌函数
</code></pre>
<h3 id="简历制作与面试技巧">简历制作与面试技巧</h3>
<h4 id="简历中的常见错误">简历中的常见错误</h4>
<p>信息过多，缺乏重点</p>
<figure data-type="image" tabindex="4"><img src="https://images.gitbook.cn/dfac3910-45f9-11e9-9c92-3786ebe58132" alt="enter image description here" loading="lazy"></figure>
<p>无意义的描述</p>
<blockquote>
<p>XXX 平台 根据项目任务要求完成爬虫模块，前端展示模块，完成数据整理与入库功能。</p>
<p>XXX 平台 构建 IP 代理池，使用 Scrapy 开发异步爬虫系统，优化爬虫策略和防屏蔽规则，提升 200% 网页抓取速度。 使用 Vue 框架完成后台管理系统，实现自定义分页，第三方登录等 6个 主要功能。 负责数据的清洗与存储到 MySQL 数据库，使用数据库索引减少 50% 数据查询时间。</p>
</blockquote>
<p>排版杂乱，错别字多</p>
<figure data-type="image" tabindex="5"><img src="https://images.gitbook.cn/6df19440-45fa-11e9-9afd-9710eb3acd93" alt="enter image description here" loading="lazy"></figure>
<h4 id="如何写一份更好的简历">如何写一份更好的简历</h4>
<figure data-type="image" tabindex="6"><img src="https://images.gitbook.cn/038a8bb0-45fb-11e9-b237-6f62ccae6012" alt="enter image description here" loading="lazy"></figure>
<h4 id="综合起来">综合起来</h4>
<figure data-type="image" tabindex="7"><img src="https://images.gitbook.cn/a55ff2a0-45fa-11e9-b237-6f62ccae6012" alt="enter image description here" loading="lazy"></figure>
<h3 id="面试技巧">面试技巧</h3>
<h4 id="好的自我介绍决定了面试的-80">好的自我介绍决定了面试的 80%</h4>
<p>不管你相不相信，你适不适合这份工作，HR 在你自我介绍的阶段，已经基本决定了。很多人在自我介绍时会犯一个错误，那就是把自己的学校情况，工作经历，兴趣爱好笼统的丢给 HR，让他自己判断你适不适合这份工作。如果你这么做了，恭喜你，你已经进入了 HR 心中的“平庸组”名单。那么，自我介绍到底应该说些什么呢？你应该斩钉截铁地告诉他：为什么这份工作非要你来做才适合！所以，每一次面试我都会告诉面试官：“我看到在招聘启事上，这份工作需要 blabla，这和我之前的工作经历中 blabla 非常类似。”</p>
<h4 id="你对我们公司了解多少">你对我们公司了解多少？</h4>
<p>这是让很多面试者头疼的一个问题，难点就在于，大家说的都差不多，你很难在众多面试者中脱颖而出。如果你按照某度的搜索结果，只是说出这家公司的行业地位，规模，企业文化等，那这个问题就算是白问了。因为，面试官其实想问的是：为什么你非得选择我们公司？我下面要说的就是：如何通过半小时的准备，给面试官留下一个难以磨灭的印象。</p>
<p>这个方法叫做：概况+细节+情绪。概况不要多说，因为这点并不决定你和其他面试者的差异。你只要说出公司的地位、总部、规模等信息即可。接下来，你就要开始说细节了，这很重要！非常简单但给人印象很深的做法是，你看几个该企业的宣传片，然后用绘声绘色、深受感染的语气描绘其中的情节，比如：“我感触特别深的就是贵公司的数据审核产品，他极大了解决了人工审核慢而且容易出错的问题，具有很好的商业前景”。这样做有什么好处？就是能在最短的时间内，调动起面试官的全部情绪。注意到其中好玩的地方了吗？面试官的情绪越高涨，对面试者留下的印象也就越深。</p>
<h4 id="离职原因处处是陷阱">离职原因——处处是陷阱</h4>
<p>离职原因是一个很重要的问题，因为它考验的不但是你的工作能力和性格，更考验你的情商和智商。不讨巧的离职原因包括：工作业绩差，沟通能力差，老板傻逼，看同事不顺眼，和公司有纠纷……所以，尽量挑一些主观上无法避免的原因，比如：公司的产品质量出了问题，公司面临破产，部门被合并，亲人有重大变故，公司的氛围和你想要的相去甚远（顺便夸夸新东家）。最重要的一点是，强调现在是你最想要稳定的时期。换句话说，就是前面那些都是浮云！</p>
<h4 id="你的缺点是什么">你的缺点是什么？</h4>
<p>缺点真的是一个非常不好答的问题，但是只要掌握了以下这个原则，这道问题也只是小菜一碟，那就是：避重就轻。什么是重？性格方面的问题，人际方面的问题，工作能力方面的原因。如果你说：“我的缺点就是耐心太差”，“我的缺点就是沟通能力有待提高”，那你真的是一个大傻帽。什么是轻？举点例子：我方向感不太好，不善于理财（金融岗位除外）之类的。有人会问了，我说了这些缺点，面试官会不会觉得我很虚伪？那我告诉你，只要你的虚伪不至于让他想吐（比如“我最大的缺点就是太追求完美”），那虚伪绝对要比傻乎乎的坦诚好。</p>
<h4 id="你有什么想问我的吗">你有什么想问我的吗？</h4>
<p>一般问到这个问题，整个面试就要结束了，但是不要掉以轻心，因为最后这个问题决定了面试官对你的最终印象。</p>
<p>所以这个问题背后的潜台词是什么呢？那就是：你还想了解一些什么，帮助你更好地留在这个公司？换言之，就是你有多想留在这个公司？ 如果你说“没有”，那么面试官说不定心里咯噔一下：原来你对这个职位兴趣也就这点啊……这个问题其实给了你表忠心的机会，你可以很认真地问她：“那如果我来到了这个公司，那每天的日常大概会是什么样的？”或者“这个公司的氛围是什么样的？”（暗示你来这里工作的强烈欲望）。</p>
<h3 id="总结">总结</h3>
<p>好了，面试攻略就分享到这里，最后送给大家一句话：找工作就是，胆大心细脸皮厚！如果你觉得这篇免费 Chat 对你有帮助，那就转发一下吧！</p>
<p>给大家介绍一下Mr. Chang的学习方法。学习的三种阶段：入门、掌握、精通。</p>
<ul>
<li>入门篇 -- 读文章 对这个知识有一定的了解，了解大概的发展趋势以及使用复杂程- 度，达到基本可以使用程度。</li>
<li>掌握篇 -- 看网上的教程 对这个知识使用并了解一些出现bug解决方案，扩展使用途径。</li>
<li>精通篇 -- 对知识体系结构已有完整认知 需要读别人写的书 加上自己亲自打代码时间 完全了解这个知识发展渊源。</li>
</ul>
<p>不论你是科班毕业还是非科班毕业，但要相信努力一定有收获，不要抱怨，趁年轻，多学习，你一定会成为 ta 心目中的哪个大英雄！</p>
<p>送给所有有梦想的我们一句话 ：相信自己，力量在心中！！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flask_SQLALchemy]]></title>
        <id>https://xiong-zh.github.io/post/flask_sqlalchemy</id>
        <link href="https://xiong-zh.github.io/post/flask_sqlalchemy">
        </link>
        <updated>2020-01-20T04:47:57.000Z</updated>
        <summary type="html"><![CDATA[<p>SQLAlchemy常用数据类型：</p>
<ol>
<li>Integer：整形，映射到数据库中是int类型。</li>
<li>Float：浮点类型，映射到数据库中是float类型。他占据的32位。</li>
<li>Double：双精度浮点类型，映射到数据库中是double类型，占据64位。</li>
<li>String：可变字符类型，映射到数据库中是varchar类型.</li>
<li>Boolean：布尔类型，映射到数据库中的是tinyint类型。</li>
<li>DECIMAL：定点类型。是专门为了解决浮点类型精度丢失的问题的。</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<p>SQLAlchemy常用数据类型：</p>
<ol>
<li>Integer：整形，映射到数据库中是int类型。</li>
<li>Float：浮点类型，映射到数据库中是float类型。他占据的32位。</li>
<li>Double：双精度浮点类型，映射到数据库中是double类型，占据64位。</li>
<li>String：可变字符类型，映射到数据库中是varchar类型.</li>
<li>Boolean：布尔类型，映射到数据库中的是tinyint类型。</li>
<li>DECIMAL：定点类型。是专门为了解决浮点类型精度丢失的问题的。</li>
</ol>
<!-- more -->
<h3 id="使用sqlalchemy去连接数据库">使用SQLAlchemy去连接数据库：</h3>
<p>使用SQLALchemy去连接数据库，需要使用一些配置信息，然后将他们组合成满足条件的字符串：</p>
<pre><code class="language-python">HOSTNAME = '127.0.0.1'
PORT = '3306'
DATABASE = 'first_sqlalchemy'
USERNAME = 'root'
PASSWORD = 'root'

# dialect+driver://username:password@host:port/database
DB_URI = &quot;mysql+pymysql://{username}:{password}@{host}:{port}/{db}?charset=utf8&quot;.format(username=USERNAME,password=PASSWORD,host=HOSTNAME,port=PORT,db=DATABASE)
</code></pre>
<p>然后使用<code>create_engine</code>创建一个引擎<code>engine</code>，然后再调用这个引擎的<code>connect</code>方法，就可以得到这个对象，然后就可以通过这个对象对数据库进行操作了：</p>
<pre><code class="language-python">engine = create_engine(DB_URI)

# 判断是否连接成功
conn = engine.connect()
result = conn.execute('select 1')
print(result.fetchone())
</code></pre>
<h3 id="orm介绍">ORM介绍：</h3>
<ol>
<li>ORM：Object Relationship Mapping</li>
<li>大白话：对象模型与数据库表的映射</li>
</ol>
<h3 id="将orm模型映射到数据库中">将ORM模型映射到数据库中：</h3>
<ol>
<li>用<code>declarative_base</code>根据<code>engine</code>创建一个ORM基类。<pre><code class="language-python">from sqlalchemy.ext.declarative import declarative_base
engine = create_engine(DB_URI)
Base = declarative_base(engine)
</code></pre>
</li>
<li>用这个<code>Base</code>类作为基类来写自己的ORM类。要定义<code>__tablename__</code>类属性，来指定这个模型映射到数据库中的表名。<pre><code class="language-python">class Person(Base):
    __tablename__ = 'person'
</code></pre>
</li>
<li>创建属性来映射到表中的字段，所有需要映射到表中的属性都应该为Column类型：<pre><code class="language-python">class Person(Base):
    __tablename__ = 'person'
    # 2. 在这个ORM模型中创建一些属性，来跟表中的字段进行一一映射。这些属性必须是sqlalchemy给我们提供好的数据类型。
    id = Column(Integer,primary_key=True,autoincrement=True)
    name = Column(String(50))
    age = Column(Integer)
</code></pre>
</li>
<li>使用<code>Base.metadata.create_all()</code>来将模型映射到数据库中。</li>
<li>一旦使用<code>Base.metadata.create_all()</code>将模型映射到数据库中后，即使改变了模型的字段，也不会重新映射了。</li>
</ol>
<h3 id="用session做数据的增删改查操作">用session做数据的增删改查操作：</h3>
<ol>
<li>构建session对象：所有和数据库的ORM操作都必须通过一个叫做<code>session</code>的会话对象来实现，通过以下代码来获取会话对象：<pre><code class="language-python">from sqlalchemy.orm import sessionmaker

engine = create_engine(DB_URI)
session = sessionmaker(engine)()
</code></pre>
</li>
<li>添加对象：
<ul>
<li>创建对象，也即创建一条数据：<pre><code class="language-python">p = Person(name='qianfeng',age=18,country='china')
</code></pre>
</li>
<li>将这个对象添加到<code>session</code>会话对象中：<pre><code class="language-python">session.add(p)
</code></pre>
</li>
<li>将session中的对象做commit操作（提交）：<pre><code class="language-python">session.commit()
</code></pre>
</li>
<li>一次性添加多条数据：<pre><code class="language-python">p1 = Person(name='qianfeng1',age=19,country='china')
p2 = Person(name='qianfeng2',age=20,country='china')
session.add_all([p1,p2])
session.commit()
</code></pre>
</li>
</ul>
</li>
<li>查找对象：<pre><code class="language-python"># 查找某个模型对应的那个表中所有的数据：
all_person = session.query(Person).all()
# 使用filter_by来做条件查询
all_person = session.query(Person).filter_by(name='qianfeng').all()
# 使用filter来做条件查询
all_person = session.query(Person).filter(Person.name=='qianfeng').all()
# 使用get方法查找数据，get方法是根据id来查找的，只会返回一条数据或者None
person = session.query(Person).get(primary_key)
# 使用first方法获取结果集中的第一条数据
person = session.query(Person).first()
</code></pre>
</li>
<li>修改对象：首先从数据库中查找对象，然后将这条数据修改为你想要的数据，最后做commit操作就可以修改数据了。<pre><code class="language-python">person = session.query(Person).first()
person.name = 'ketang'
session.commit()
</code></pre>
</li>
<li>删除对象：将需要删除的数据从数据库中查找出来，然后使用<code>session.delete</code>方法将这条数据从session中删除，最后做commit操作就可以了。<pre><code class="language-python">person = session.query(Person).first()
session.delete(person)
session.commit()
</code></pre>
</li>
</ol>
<h3 id="sqlalchemy常用数据类型">SQLAlchemy常用数据类型：</h3>
<ol>
<li>Integer：整形，映射到数据库中是int类型。</li>
<li>Float：浮点类型，映射到数据库中是float类型。他占据的32位。</li>
<li>Double：双精度浮点类型，映射到数据库中是double类型，占据64位。</li>
<li>String：可变字符类型，映射到数据库中是varchar类型.</li>
<li>Boolean：布尔类型，映射到数据库中的是tinyint类型。</li>
<li>DECIMAL：定点类型。是专门为了解决浮点类型精度丢失的问题的。在存储钱相关的字段的时候建议大家都使用这个数据类型。并且这个类型使用的时候需要传递两个参数，第一个参数是用来标记这个字段总能能存储多少个数字，第二个参数表示小数点后有多少位。</li>
<li>Enum：枚举类型。指定某个字段只能是枚举中指定的几个值，不能为其他值。在ORM模型中，使用Enum来作为枚举，示例代码如下：<pre><code class="language-python">class Article(Base):
    __tablename__ = 'article'
    id = Column(Integer,primary_key=True,autoincrement=True)
    tag = Column(Enum(&quot;python&quot;,'flask','django'))
</code></pre>
在Python3中，已经内置了enum这个枚举的模块，我们也可以使用这个模块去定义相关的字段。示例代码如下：<pre><code class="language-python">class TagEnum(enum.Enum):
    python = &quot;python&quot;
    flask = &quot;flask&quot;
    django = &quot;django&quot;

class Article(Base):
    __tablename__ = 'article'
    id = Column(Integer,primary_key=True,autoincrement=True)
    tag = Column(Enum(TagEnum))

article = Article(tag=TagEnum.flask)
</code></pre>
</li>
<li>Date：存储时间，只能存储年月日。映射到数据库中是date类型。在Python代码中，可以使用<code>datetime.date</code>来指定。示例代码如下：<pre><code class="language-python">class Article(Base):
    __tablename__ = 'article'
    id = Column(Integer,primary_key=True,autoincrement=True)
    create_time = Column(Date)

article = Article(create_time=date(2017,10,10))
</code></pre>
</li>
<li>DateTime：存储时间，可以存储年月日时分秒毫秒等。映射到数据库中也是datetime类型。在Python代码中，可以使用<code>datetime.datetime</code>来指定。示例代码如下：<pre><code class="language-python">class Article(Base):
    __tablename__ = 'article'
    id = Column(Integer,primary_key=True,autoincrement=True)
    create_time = Column(DateTime)

article = Article(create_time=datetime(2011,11,11,11,11,11))
</code></pre>
</li>
<li>Time：存储时间，可以存储时分秒。映射到数据库中也是time类型。在Python代码中，可以使用<code>datetime.time</code>来至此那个。示例代码如下：<pre><code class="language-python">class Article(Base):
    __tablename__ = 'article'
    id = Column(Integer,primary_key=True,autoincrement=True)
    create_time = Column(Time)

article = Article(create_time=time(hour=11,minute=11,second=11))
</code></pre>
</li>
<li>Text：存储长字符串。一般可以存储6W多个字符。如果超出了这个范围，可以使用LONGTEXT类型。映射到数据库中就是text类型。</li>
<li>LONGTEXT：长文本类型，映射到数据库中是longtext类型。</li>
</ol>
<h3 id="column常用参数">Column常用参数：</h3>
<ol>
<li>primary_key：设置某个字段为主键。</li>
<li>autoincrement：设置这个字段为自动增长的。</li>
<li>default：设置某个字段的默认值。在发表时间这些字段上面经常用。</li>
<li>nullable：指定某个字段是否为空。默认值是True，就是可以为空。</li>
<li>unique：指定某个字段的值是否唯一。默认是False。</li>
<li>onupdate：在数据更新的时候会调用这个参数指定的值或者函数。在第一次插入这条数据的时候，不会用onupdate的值，只会使用default的值。常用的就是<code>update_time</code>（每次更新数据的时候都要更新的值）。</li>
<li>name：指定ORM模型中某个属性映射到表中的字段名。如果不指定，那么会使用这个属性的名字来作为字段名。如果指定了，就会使用指定的这个值作为参数。这个参数也可以当作位置参数，在第1个参数来指定。<pre><code class="language-python">title = Column(String(50),name='title',nullable=False)
title = Column('my_title',String(50),nullable=False)
</code></pre>
</li>
</ol>
<h3 id="query可用参数">query可用参数：</h3>
<ol>
<li>
<p>模型对象。指定查找这个模型中所有的对象。</p>
</li>
<li>
<p>模型中的属性。可以指定只查找某个模型的其中几个属性。</p>
</li>
<li>
<p>聚合函数。</p>
<ul>
<li>func.count：统计行的数量。</li>
<li>func.avg：求平均值。</li>
<li>func.max：求最大值。</li>
<li>func.min：求最小值。</li>
<li>func.sum：求和。<br>
<code>func</code>上，其实没有任何聚合函数。但是因为他底层做了一些魔术，只要mysql中有的聚合函数，都可以通过func调用。</li>
</ul>
<pre><code>from flask import func
session.query(func.count(Article.id)).first()
</code></pre>
</li>
</ol>
<h3 id="filter过滤条件">filter过滤条件：</h3>
<p>过滤是数据提取的一个很重要的功能，以下对一些常用的过滤条件进行解释，并且这些过滤条件都是只能通过filter方法实现的：</p>
<ol>
<li>
<p>equals：</p>
<pre><code class="language-python">article = session.query(Article).filter(Article.title == &quot;title0&quot;).first()
print(article)
</code></pre>
</li>
<li>
<p>not equals:</p>
<pre><code class="language-python">query.filter(User.name != 'ed')
</code></pre>
</li>
<li>
<p>like：</p>
<pre><code class="language-python">query.filter(User.name.like('%ed%'))
</code></pre>
</li>
<li>
<p>in：</p>
<pre><code class="language-python">query.filter(User.name.in_(['ed','wendy','jack']))
# 同时，in也可以作用于一个Query
query.filter(User.name.in_(session.query(User.name).filter(User.name.like('%ed%'))))
</code></pre>
</li>
<li>
<p>not in：</p>
<pre><code class="language-python">query.filter(~User.name.in_(['ed','wendy','jack']))
</code></pre>
</li>
<li>
<p>is null：</p>
<pre><code class="language-python">query.filter(User.name==None)
# 或者是
query.filter(User.name.is_(None))
</code></pre>
</li>
<li>
<p>is not null:</p>
<pre><code class="language-python">query.filter(User.name != None)
# 或者是
query.filter(User.name.isnot(None))
</code></pre>
</li>
<li>
<p>and：</p>
<pre><code class="language-python">from sqlalchemy import and_
query.filter(and_(User.name=='ed',User.fullname=='Ed Jones'))
# 或者是传递多个参数
query.filter(User.name=='ed',User.fullname=='Ed Jones')
# 或者是通过多次filter操作
query.filter(User.name=='ed').filter(User.fullname=='Ed Jones')
</code></pre>
</li>
<li>
<p>or：</p>
<pre><code class="language-python">from sqlalchemy import or_  query.filter(or_(User.name=='ed',User.name=='wendy'))
</code></pre>
</li>
</ol>
<p>如果想要查看orm底层转换的sql语句，可以在filter方法后面不要再执行任何方法直接打印就可以看到了。比如：<br>
​    <code>python ​ articles = session.query(Article).filter(or_(Article.title=='abc',Article.content=='abc')) ​ print(articles) ​</code></p>
<h3 id="外键">外键：</h3>
<p>使用SQLAlchemy创建外键非常简单。在从表中增加一个字段，指定这个字段外键的是哪个表的哪个字段就可以了。从表中外键的字段，必须和父表的主键字段类型保持一致。<br>
示例代码如下：</p>
<pre><code class="language-python">class User(Base):
    __tablename__ = 'user'
    id = Column(Integer,primary_key=True,autoincrement=True)
    username = Column(String(50),nullable=False)

class Article(Base):
    __tablename__ = 'article'
    id = Column(Integer,primary_key=True,autoincrement=True)
    title = Column(String(50),nullable=False)
    content = Column(Text,nullable=False)

    uid = Column(Integer,ForeignKey(&quot;user.id&quot;))
</code></pre>
<p>外键约束有以下几项：</p>
<ol>
<li>RESTRICT：父表数据被删除，会阻止删除。默认就是这一项。 用户和订单 如果删除用户数据会被阻止 除非先删除相关订单 才能删除用户数据</li>
<li>NO ACTION：在MySQL中，同RESTRICT。</li>
<li>CASCADE：级联删除。</li>
<li>SET NULL：父表数据被删除，子表数据会设置为NULL。</li>
</ol>
<h3 id="orm关系以及一对多-一个用户可以写多篇文章-一篇文章只属于一个用户">ORM关系以及一对多： 一个用户可以写多篇文章  一篇文章只属于一个用户</h3>
<p>mysql级别的外键，还不够ORM，必须拿到一个表的外键，然后通过这个外键再去另外一张表中查找，这样太麻烦了。SQLAlchemy提供了一个<code>relationship</code>，这个类可以定义属性，以后在访问相关联的表的时候就直接可以通过属性访问的方式就可以访问得到了。示例代码：</p>
<pre><code class="language-python">class User(Base):
    __tablename__ = 'user'
    id = Column(Integer,primary_key=True,autoincrement=True)
    username = Column(String(50),nullable=False)

    # articles = relationship(&quot;Article&quot;)

    def __repr__(self):
        return &quot;&lt;User(username:%s)&gt;&quot; % self.username

class Article(Base):
    __tablename__ = 'article'
    id = Column(Integer,primary_key=True,autoincrement=True)
    title = Column(String(50),nullable=False)
    content = Column(Text,nullable=False)
    uid = Column(Integer,ForeignKey(&quot;user.id&quot;))  
	# MyISAM引擎不支持外键  Innodb引擎才支持

    author = relationship(&quot;User&quot;,backref=&quot;articles&quot;)
</code></pre>
<p>另外，可以通过<code>backref</code>来指定反向访问的属性名称。articles是有多个。他们之间的关系是一个一对多的关系。</p>
<h3 id="一对一的关系-一张表-有五个字段-不想在此基础上增加字段还想扩展-这时候可以新建一张表-然后一对一">一对一的关系： 一张表 有五个字段 不想在此基础上增加字段还想扩展 这时候可以新建一张表  然后一对一</h3>
<p>在sqlalchemy中，如果想要将两个模型映射成一对一的关系，那么应该在父模型中，指定引用的时候，要传递一个<code>uselist=False</code>这个参数进去。就是告诉父模型，以后引用这个从模型的时候，不再是一个列表了，而是一个对象了。示例代码如下：</p>
<pre><code class="language-python">class User(Base):
    __tablename__ = 'user'
    id = Column(Integer,primary_key=True,autoincrement=True)
    username = Column(String(50),nullable=False)

    extend = relationship(&quot;UserExtend&quot;,uselist=False)

    def __repr__(self):
        return &quot;&lt;User(username:%s)&gt;&quot; % self.username

class UserExtend(Base):
    __tablename__ = 'user_extend'
    id = Column(Integer, primary_key=True, autoincrement=True)
    school = Column(String(50))
    uid = Column(Integer,ForeignKey(&quot;user.id&quot;))

    user = relationship(&quot;User&quot;,backref=&quot;extend&quot;)
</code></pre>
<p>当然，也可以借助<code>sqlalchemy.orm.backref</code>来简化代码：</p>
<pre><code class="language-python">class User(Base):
    __tablename__ = 'user'
    id = Column(Integer,primary_key=True,autoincrement=True)
    username = Column(String(50),nullable=False)

    # extend = relationship(&quot;UserExtend&quot;,uselist=False)

    def __repr__(self):
        return &quot;&lt;User(username:%s)&gt;&quot; % self.username

class UserExtend(Base):
    __tablename__ = 'user_extend'
    id = Column(Integer, primary_key=True, autoincrement=True)
    school = Column(String(50))
    uid = Column(Integer,ForeignKey(&quot;user.id&quot;))

    user = relationship(&quot;User&quot;,backref=backref(&quot;extend&quot;,uselist=False))
</code></pre>
<h3 id="多对多的关系文章和标签-一个文章有多个标签-一个标签可以属于多个标签">多对多的关系：文章和标签 一个文章有多个标签  一个标签可以属于多个标签</h3>
<ol>
<li>多对多的关系需要通过一张中间表来绑定他们之间的关系。</li>
<li>先把两个需要做多对多的模型定义出来</li>
<li>使用Table定义一个中间表，中间表一般就是包含两个模型的外键字段就可以了，并且让他们两个来作为一个“复合主键”。</li>
<li>在两个需要做多对多的模型中随便选择一个模型，定义一个relationship属性，来绑定三者之间的关系，在使用relationship的时候，需要传入一个secondary=中间表。</li>
</ol>
<h3 id="orm层面的删除数据">ORM层面的删除数据：</h3>
<p>ORM层面删除数据，会无视mysql级别的外键约束。直接会将对应的数据删除，然后将从表中的那个外键设置为NULL。如果想要避免这种行为，应该将从表中的外键的<code>nullable=False</code>。<br>
在SQLAlchemy，只要将一个数据添加到session中，和他相关联的数据都可以一起存入到数据库中了。这些是怎么设置的呢？其实是通过relationship的时候，有一个关键字参数cascade可以设置这些属性：</p>
<ol>
<li>save-update：默认选项。在添加一条数据的时候，会把其他和他相关联的数据都添加到数据库中。这种行为就是save-update属性影响的。</li>
<li>delete：表示当删除某一个模型中的数据的时候，是否也删掉使用relationship和他关联的数据。</li>
<li>delete-orphan：表示当对一个ORM对象解除了父表中的关联对象的时候，自己便会被删除掉。当然如果父表中的数据被删除，自己也会被删除。这个选项只能用在一对多上，不能用在多对多以及多对一上。并且还需要在子模型中的relationship中，增加一个single_parent=True的参数。</li>
<li>merge：默认选项。当在使用session.merge，合并一个对象的时候，会将使用了relationship相关联的对象也进行merge操作。</li>
<li>expunge：移除操作的时候，会将相关联的对象也进行移除。这个操作只是从session中移除，并不会真正的从数据库中删除。</li>
<li>all：是对save-update, merge, refresh-expire, expunge, delete几种的缩写。</li>
</ol>
<h3 id="排序">排序：</h3>
<ol>
<li>
<p>order_by：可以指定根据这个表中的某个字段进行排序，如果在前面加了一个-，代表的是降序排序。</p>
</li>
<li>
<p>在模型定义的时候指定默认排序：有些时候，不想每次在查询的时候都指定排序的方式，可以在定义模型的时候就指定排序的方式。有以下两种方式：</p>
<ul>
<li>relationship的order_by参数：在指定relationship的时候，传递order_by参数来指定排序的字段。</li>
<li>在模型定义中，添加以下代码：</li>
</ul>
<p><strong>mapper_args</strong> = {<br>
​     &quot;order_by&quot;: title<br>
}</p>
<p>即可让文章使用标题来进行排序。</p>
</li>
<li>
<pre><code> __mapper_args__ = {    &quot;order_by&quot;:create_time.desc()} 倒序 
</code></pre>
</li>
<li>
<p>正序排序与倒序排序：默认是使用正序排序。如果需要使用倒序排序，那么可以使用这个字段的<code>desc()</code>方法，或者是在排序的时候使用这个字段的字符串名字，然后在前面加一个负号。</p>
</li>
</ol>
<h3 id="limit-offset和切片操作">limit、offset和切片操作：</h3>
<ol>
<li>limit：可以限制每次查询的时候只查询几条数据。</li>
<li>offset：可以限制查找数据的时候过滤掉前面多少条。</li>
<li>切片：可以对Query对象使用切片操作，来获取想要的数据。可以使用<code>slice(start,stop)</code>方法来做切片操作。也可以使用<code>[start:stop]</code>的方式来进行切片操作。一般在实际开发中，中括号的形式是用得比较多的。希望大家一定要掌握。示例代码如下：</li>
</ol>
<pre><code class="language-python">articles = session.query(Article).order_by(Article.id.desc())[0:10]
</code></pre>
<h3 id="懒加载">懒加载：</h3>
<p>在一对多，或者多对多的时候，如果想要获取多的这一部分的数据的时候，往往能通过一个属性就可以全部获取了。比如有一个作者，想要或者这个作者的所有文章，那么可以通过user.articles就可以获取所有的。但有时候我们不想获取所有的数据，比如只想获取这个作者今天发表的文章，那么这时候我们可以给relationship传递一个lazy='dynamic'，以后通过user.articles获取到的就不是一个列表，而是一个AppenderQuery对象了。这样就可以对这个对象再进行一层过滤和排序等操作。<br>
通过<code>lazy='dynamic'</code>，获取出来的多的那一部分的数据，就是一个<code>AppenderQuery</code>对象了。这种对象既可以添加新数据，也可以跟<code>Query</code>一样，可以再进行一层过滤。<br>
总而言之一句话：如果你在获取数据的时候，想要对多的那一边的数据再进行一层过滤，那么这时候就可以考虑使用<code>lazy='dynamic'</code>。<br>
lazy可用的选项：</p>
<ol>
<li><code>select</code>：这个是默认选项。还是拿<code>user.articles</code>的例子来讲。如果你没有访问<code>user.articles</code>这个属性，那么sqlalchemy就不会从数据库中查找文章。一旦你访问了这个属性，那么sqlalchemy就会立马从数据库中查找所有的文章，并把查找出来的数据组装成一个列表返回。这也是懒加载。</li>
<li><code>dynamic</code>：这个就是我们刚刚讲的。就是在访问<code>user.articles</code>的时候返回回来的不是一个列表，而是<code>AppenderQuery</code>对象。</li>
</ol>
<h3 id="group_by">group_by：</h3>
<p>根据某个字段进行分组。比如想要根据性别进行分组，来统计每个分组分别有多少人，那么可以使用以下代码来完成：</p>
<pre><code class="language-python">session.query(User.gender,func.count(User.id)).group_by(User.gender).all()
</code></pre>
<h3 id="having">having：</h3>
<p>having是对查找结果进一步过滤。比如只想要看未成年人的数量，那么可以首先对年龄进行分组统计人数，然后再对分组进行having过滤。示例代码如下：</p>
<pre><code class="language-python">result = session.query(User.age,func.count(User.id)).group_by(User.age).having(User.age &gt;= 18).all()
</code></pre>
<h3 id="join">join：</h3>
<ol>
<li>join分为left join（左外连接）和right join（右外连接）以及内连接（等值连接）。</li>
<li>参考的网页：http://www.jb51.net/article/15386.htm</li>
<li>在sqlalchemy中，使用join来完成内连接。在写join的时候，如果不写join的条件，那么默认将使用外键来作为条件连接。</li>
<li>query查找出来什么值，不会取决于join后面的东西，而是取决于query方法中传了什么参数。就跟原生sql中的select 后面那一个一样。<br>
比如现在要实现一个功能，要查找所有用户，按照发表文章的数量来进行排序。示例代码如下：</li>
</ol>
<pre><code class="language-python">result = session.query(User,func.count(Article.id)).join(Article).group_by(User.id).order_by(func.count(Article.id).desc()).all()
</code></pre>
<h3 id="subquery">subquery：</h3>
<p>子查询可以让多个查询变成一个查询，只要查找一次数据库，性能相对来讲更加高效一点。不用写多个sql语句就可以实现一些复杂的查询。那么在sqlalchemy中，要实现一个子查询，应该使用以下几个步骤：</p>
<ol>
<li>将子查询按照传统的方式写好查询代码，然后在<code>query</code>对象后面执行<code>subquery</code>方法，将这个查询变成一个子查询。</li>
<li>在子查询中，将以后需要用到的字段通过<code>label</code>方法，取个别名。</li>
<li>在父查询中，如果想要使用子查询的字段，那么可以通过子查询的返回值上的<code>c</code>属性拿到。<br>
整体的示例代码如下：</li>
</ol>
<pre><code class="language-python">dstmt = session.query(User.city.label(&quot;city&quot;),User.age.label(&quot;age&quot;)).filter(User.username=='李A').subquery()
result = session.query(User).filter(User.city==stmt.c.city,User.age==stmt.c.age).all()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[个人书籍]]></title>
        <id>https://xiong-zh.github.io/post/ge-ren-shu-ji</id>
        <link href="https://xiong-zh.github.io/post/ge-ren-shu-ji">
        </link>
        <updated>2020-01-19T07:10:35.000Z</updated>
        <summary type="html"><![CDATA[<p>注： 在学习和工作的过程中，遇到一些bug，大佬难寻或一时难已解决，或需求与现状对不上等一系列问题，于是萌生了写一些较完整成体系的文章记录遇到的问题和解决之道的文章。所以一下的书籍就这样出现了。<br>
其中还有非常多的想法还没有实现，或者还没有呈现出来，有许多不完美的地方，在后续会不断实现并加以完善。在这里诚恳的希望读者能提出宝贵的意见和你的期待，你可以通过本博客中留的方式联系到我。</p>
]]></summary>
        <content type="html"><![CDATA[<p>注： 在学习和工作的过程中，遇到一些bug，大佬难寻或一时难已解决，或需求与现状对不上等一系列问题，于是萌生了写一些较完整成体系的文章记录遇到的问题和解决之道的文章。所以一下的书籍就这样出现了。<br>
其中还有非常多的想法还没有实现，或者还没有呈现出来，有许多不完美的地方，在后续会不断实现并加以完善。在这里诚恳的希望读者能提出宝贵的意见和你的期待，你可以通过本博客中留的方式联系到我。</p>
<!-- more -->
<p>注： 在学习和工作的过程中，遇到一些bug，大佬难寻或一时难已解决，或需求与现状对不上等一系列问题，于是萌生了写一些较完整成体系的文章记录遇到的问题和解决之道的文章。所以一下的书籍就这样出现了。<br>
其中还有非常多的想法还没有实现，或者还没有呈现出来，有许多不完美的地方，在后续会不断实现并加以完善。在这里诚恳的希望读者能提出宝贵的意见和你的期待，你可以通过本博客中留的方式联系到我，跪谢🙏。</p>
<h2 id="教程">教程</h2>
<p><a href="https://python.zhangxiong.net">Python</a></p>
<ul>
<li>Python是那些可以声称既简单又强大的罕见语言之一。您会惊喜地发现，专注于问题的解决方案而不是您编程语言的语法和结构是多么容易。</li>
<li>Python是一种简单而简约的语言。阅读一个好的Python程序感觉就像阅读英语，虽然英语非常严格！Python的这种伪代码特性是它最大的优势之一。它允许您专注于问题的解决方案而不是语言本身。</li>
</ul>
<p><a href="https://django.zhangxiong.net">Django</a></p>
<ul>
<li>在我们编写的所有程序中，我们已经围绕函数设计了我们的程序，即操作数据的语句块。这称为面向过程的编程方式。还有另一种组织程序的方法，即组合数据和功能并将其包装在称为对象的内容中。这称为面向对象编程范例。大多数情况下，您可以使用过程编程，但在编写大型程序或遇到更适合此方法的问题时，可以使用面向对象的编程技术。</li>
</ul>
<h2 id="想法">想法</h2>
<p><a href="https://yscg.zhangxiong.net">一切都刚刚好</a></p>
<ul>
<li>其实也过写点东西的冲动，但有时候身边写作条件达不到，又或者思如泉涌，提笔忘字，写出来也不太尽如人意，内心想法表达不出来。同时感觉写了只是自己看， 又或者不自信不愿意分享，常常搁浅。其实许多事都没我们想的那么难，难就难在对未知的恐惧，安于现状，不敢走出舒适圈，只要跨过了，就会成为自然而然对事。</li>
</ul>
<p><a href="https://gqlx.zhangxiong.net">归去来兮</a> 暂未完成</p>
<h3 id="更多作品敬请期待">更多作品敬请期待···</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django urls与视图详解]]></title>
        <id>https://xiong-zh.github.io/post/Django-urls与视图详解</id>
        <link href="https://xiong-zh.github.io/post/Django-urls与视图详解">
        </link>
        <updated>2020-01-18T13:12:17.000Z</updated>
        <summary type="html"><![CDATA[<p>Django urls与视图详解</p>
]]></summary>
        <content type="html"><![CDATA[<p>Django urls与视图详解</p>
<!-- more -->
<h1 id="urls与视图详解"><code>urls</code>与视图详解</h1>
<blockquote>
<p>环境 <code>Windows10</code></p>
</blockquote>
<h2 id="一-准备工作">一、准备工作</h2>
<ul>
<li>
<p>使用 <code>virtualenvwrapper</code> 创建并进入虚拟环境</p>
<pre><code>mkvirtualenv myenv
</code></pre>
</li>
<li>
<p>安装 <code>Django2.0</code></p>
<pre><code>pip install django==2.0
</code></pre>
</li>
<li>
<p>查看是否安装成功</p>
<pre><code>pip list
</code></pre>
</li>
<li>
<p>创建一个名为 <code>mysite</code> 的 <code>django</code> 项目</p>
<pre><code>django-admin startproject mysite
</code></pre>
</li>
<li>
<p>进入虚拟环境所在目录</p>
<pre><code>cdvirtualenv
</code></pre>
</li>
<li>
<p>打开当前目录</p>
<pre><code>start %cd%
</code></pre>
</li>
<li>
<p>将 <code>mysite</code> 目录拖到 <code>pycharm</code> 打开</p>
</li>
<li>
<p>设置 <code>pycharm</code> 的 <code>python</code> 环境</p>
</li>
</ul>
<h2 id="二-项目结构分析">二、项目结构分析</h2>
<ul>
<li>
<p><code>manange.py</code> 项目的管理与交互都基于这个文件， 如启动项目：</p>
<pre><code>python manange.py runserver
</code></pre>
</li>
<li>
<p><code>__init__.py</code> 表示这是一个 <code>python</code> 模块</p>
</li>
<li>
<p><code>setting.py</code> 保存项目的所有配置信息</p>
</li>
<li>
<p><code>urls.py</code> 编写路由与视图的映射规则</p>
</li>
<li>
<p><code>wsig.py</code> 项目部署文件</p>
</li>
</ul>
<h2 id="三-debug-模式-与-allowed_hosts">三、<code>DEBUG</code> 模式  与 <code>ALLOWED_HOSTS</code></h2>
<ul>
<li>在 <code>mysite/settings.py</code> 中 默认是开启了 <code>DEBUG</code> 模式的</li>
</ul>
<pre><code>DEBUG = True
</code></pre>
<ul>
<li>
<p><code>DEBUG</code> 模式的作用</p>
<ul>
<li>修改后自动重启项目</li>
<li>详细的报错详细</li>
</ul>
</li>
<li>
<p>关闭了 <code>DEBUG</code> 模式，必须设置 <code>ALLOWED_HOSTS</code>, 否则项目起不来</p>
</li>
</ul>
<pre><code>ALLOWED_HOSTS = ['127.0.0.1', 'localhost', '192.168.0.108']
</code></pre>
<ul>
<li>
<p><code>DEBUG</code> 模式, 默认是以 <code>IP</code> <code>0.0.0.0</code> 启动服务的， 但只要设置了 <code>ALLOWED_HOSTS</code>， 就只能通过<code>ALLOWED_HOSTS</code> 中的 <code>IP</code> 或 域名进行访问</p>
</li>
<li>
<p>开发阶段，开启 <code>DEBUG</code>, 线上环境必须关闭 <code>DEBUG</code> 模式</p>
</li>
</ul>
<h2 id="四-root_urlconf-设置-urls-匹配的入口文件">四、<code>ROOT_URLCONF</code> 设置 <code>urls</code> 匹配的入口文件</h2>
<pre><code>ROOT_URLCONF = 'mysite.urls'
</code></pre>
<h2 id="五-初识视图函数">五、初识视图函数</h2>
<ul>
<li>视图函数的第一个参数永远是 <code>HttpRequest</code> 对象</li>
<li>视图函数只能返回 <code>HttpResponseBase</code>的子类对象</li>
</ul>
<pre><code>from django.http import HttpResponse
def index(request):
    return HttpResponse('cms首页')
</code></pre>
<h2 id="六-urls-分层模块化">六、<code>urls</code> 分层模块化</h2>
<ul>
<li>
<p>每个独立的模块对应 <code>Django</code> 的一个 <code>app</code></p>
</li>
<li>
<p>创建两个 <code>app</code> : <code>front</code> 和 <code>cms</code></p>
</li>
</ul>
<pre><code>  # 创建前台模块
  python manange.py startapp front

  # 创建后台cms模块
  python manange.py startapp cms
</code></pre>
<ul>
<li>编写 <code>front/views.py</code></li>
</ul>
<pre><code class="language-python"># from django.shortcuts import render
from django.http import HttpResponse
# Create your views here.
def index(request):
   return HttpResponse('前台首页')
</code></pre>
<ul>
<li>编写 <code>cms/views.py</code></li>
</ul>
<pre><code class="language-python">  # from django.shortcuts import render
from django.http import HttpResponse
def index(request):
    return HttpResponse('cms首页')
</code></pre>
<ul>
<li>创建 <code>front/urls.py</code></li>
</ul>
<pre><code class="language-python">from django.urls import path
from . import views
app_name = 'front'
urlpatterns = [
      path('', views.index, name='index')
  ]
</code></pre>
<ul>
<li>创建 <code>cms/urls.py</code></li>
</ul>
<pre><code class="language-python">from django.urls import path
from . import views
app_name = 'cms'
urlpatterns = [
      path('', views.index, name='index')
  ]
</code></pre>
<ul>
<li>编写 <code>mysite/urls.py</code></li>
</ul>
<pre><code class="language-python">from django.contrib import admin
from django.urls import path, include
urlpatterns = [
      path('admin/', admin.site.urls),
      path('', include('front.urls')),
      path('cms/', include('cms.urls')),
  ]
</code></pre>
<ul>
<li>启动项目</li>
</ul>
<pre><code class="language-shell"> python manange.py runserver
</code></pre>
<ul>
<li>
<p>访问 <code>front</code> 应用： <code>http://127.0.0.1:8000</code></p>
</li>
<li>
<p>访问 <code>cms</code> 应用： <code>http://127.0.0.1:8000/cms/</code></p>
</li>
</ul>
<h2 id="七-url中的参数传递">七、<code>url</code>中的参数传递</h2>
<ul>
<li>通过 <code>path</code> 传递</li>
<li>编写视图函数 <code>front/views.py</code></li>
</ul>
<pre><code class="language-python">def detail(request, article_id):
    return HttpResponse('当前文章id: %s' % article_id)
</code></pre>
<ul>
<li>编写urls <code>front/urls.py</code></li>
</ul>
<pre><code class="language-python">path('detail/&lt;article_id&gt;', views.detail, name='detail'),
</code></pre>
<ul>
<li>
<p>访问方式： <code>http://localhost:8000/detail/1</code></p>
</li>
<li>
<p>通过 查询字符串 传递</p>
</li>
<li>
<p>编写视图函数 <code>front/views.py</code></p>
</li>
</ul>
<pre><code class="language-python">def article_list(request):
    author = request.GET.get('author')
    return HttpResponse('%s 相关的文章' % author)
</code></pre>
<ul>
<li>
<p>编写urls <code>front/urls.py</code></p>
<pre><code class="language-python">path('list/', views.article_list, name='list'),
</code></pre>
</li>
<li>
<p>访问方式： <code>http://localhost:8000/list/?author=%E6%9D%8E%E7%99%BD</code></p>
</li>
</ul>
<h2 id="八-内置的-path-转换器">八、 内置的 <code>path</code> 转换器</h2>
<ul>
<li><code>int</code> 类型：
<ul>
<li>
<p>实现原理如下</p>
<pre><code class="language-python">class IntConverter:
  regex = '[0-9]+'

  def to_python(self, value):
      return int(value)

  def to_url(self, value):
      return str(value)
</code></pre>
</li>
<li>
<p>改写 <code>front/urls.py</code></p>
<pre><code class="language-python">path('detail/&lt;int:article_id&gt;', views.detail, name='detail'),
</code></pre>
</li>
<li>
<p>改写  <code>front/views.py</code></p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-python">def detail(request, article_id):
    print(type(article_id))
    return HttpResponse('当前文章id: %s' % article_id)
</code></pre>
<ul>
<li>
<p>访问： <strong>http://localhost:8000/detail/1</strong></p>
</li>
<li>
<p>控制台输出 <code>&lt;class 'int'&gt;</code></p>
</li>
<li>
<p><code>str</code> 类型， 默认不指定类型，就是 <code>str</code> 类型</p>
<ul>
<li>原理：</li>
</ul>
</li>
</ul>
<pre><code class="language-python">class StringConverter:
    regex = '[^/]+'
    def to_python(self, value):
        return value
    def to_url(self, value):
        return value
</code></pre>
<ul>
<li><code>uuid</code> 类型，通用唯一识别码
<ul>
<li>原理：</li>
</ul>
</li>
</ul>
<pre><code class="language-python">class UUIDConverter:
    regex = '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}'
    def to_python(self, value):
        return uuid.UUID(value)
    def to_url(self, value):
        return str(value)
</code></pre>
<ul>
<li>
<p>生成一个<code>uuid</code> 如： <code>b8f12562-7006-4e21-9aeb-c3426d9dcbd3</code></p>
<pre><code class="language-shell">python

import uuid

uuid.uuid4()
</code></pre>
</li>
<li>
<p>改写 <code>front/urls.py</code></p>
<pre><code class="language-python">path('detail/&lt;uuid:article_id&gt;', views.detail, name='detail'),
</code></pre>
</li>
<li>
<p>访问： <code>http://localhost:8000/detail/b8f12562-7006-4e21-9aeb-c3426d9dcbd3</code></p>
</li>
<li>
<p><code>slug</code> 类型</p>
<ul>
<li>原理：</li>
</ul>
</li>
</ul>
<pre><code class="language-python">regex = '[-a-zA-Z0-9_]+'
</code></pre>
<ul>
<li><code>path</code> 类型</li>
<li>原理：</li>
</ul>
<pre><code class="language-python">regex = '.+'
</code></pre>
<h2 id="九-自定义-path-转换器">九、自定义 <code>path</code> 转换器</h2>
<p><strong>这里，我们实现一个规则为： python+django+flask 的 <code>url</code> 参数， <code>python</code> 代码接收到的是通过 <code>+</code> 拆分后的列表, 转换器接收的参数也必须是一个列表； 比较抽象，还是看代码吧！</strong></p>
<ul>
<li>创建 <code>front/converters.py</code></li>
</ul>
<pre><code>from django.urls import register_converter
class CateConverter:
      regex = r'\w+|(\w+\+\w+)+'
      def to_python(self, value):
          return value.split('+')
      def to_url(self, value):
          if isinstance(value, list):
              return '+'.join(value)
          else:
              raise RuntimeError('分类参数必须为 list 类型')
# 注册 path 转换器
    register_converter(CateConverter, 'cate')
</code></pre>
<ul>
<li>修改 <code>front/__init__.py</code></li>
</ul>
<pre><code class="language-python"># 运行我们自定义的转换器
from . import converters
</code></pre>
<ul>
<li>修改 <code>front/urls.py</code></li>
</ul>
<pre><code class="language-python">path('category/&lt;cate:category&gt;/', views.index_category, name='category'),
</code></pre>
<ul>
<li>修改 <code>front/views.py</code></li>
</ul>
<pre><code>def index_category(request, category):
    pathname = reverse('front:category', kwargs={'category': category})
    return HttpResponse('分类列表为： %s, url 的 pathname 部分为： %s' % (category, pathname))
</code></pre>
<ul>
<li>访问： <code>http://localhost:8000/category/python+django/</code>, 浏览器显示如下：</li>
</ul>
<p><code>分类列表为： ['python', 'django'], url 的 pathname 部分为： /category/python+django/</code></p>
<h2 id="十-重定向-与-url-命名反转">十、重定向 与 <code>url</code> 命名反转</h2>
<blockquote>
<p>通过模拟 <code>cms</code> 后台登录进行讲解</p>
</blockquote>
<ul>
<li>修改 <code>cms/urls.py</code></li>
</ul>
<pre><code class="language-python">path('login/', views.login, name='login'),
</code></pre>
<ul>
<li>修改 <code>cms/views.py</code></li>
</ul>
<pre><code>  # from django.shortcuts import render
  from django.http import HttpResponse
  from django.shortcuts import redirect, reverse

  # Create your views here.


  def index(request):
      username = request.GET.get('username')
      if username:
          return HttpResponse('cms首页')
      else:
          # 重定向登录页面
          return redirect(reverse('cms:login'))  # url 命名反转


  def login(request):
      return HttpResponse('登录页面')

</code></pre>
<ul>
<li>
<p>访问： <code>http://localhost:8000/cms/</code> 会自动跳转到登录页面</p>
</li>
<li>
<p>访问： <code>http://localhost:8000/cms/?username=zhb33</code> 才能访问 <code>cms</code> 后台首页</p>
</li>
<li>
<p><code>url</code> 命名反转时的参数传递</p>
<blockquote>
<p>如果反转时，<code>url</code> 需要接收参数， 可通过关键字参数传递， 如果传递的查询字符串， 需要手动进行拼接</p>
</blockquote>
<ul>
<li>修改 <code>cms/urls.py</code></li>
</ul>
</li>
</ul>
<pre><code>  path('login/&lt;location&gt;', views.login, name='login'),
</code></pre>
<ul>
<li>修改 <code>cms/views.py</code></li>
</ul>
<pre><code>  def index(request):
    username = request.GET.get('username')
    if username:
        return HttpResponse('cms首页')
    else:
        # 重定向登录页面
        login_url = reverse('cms:login', kwargs={'location': '深圳'})  # url传参
        login_url += '?next=/'  # 查询字符串
        return redirect(login_url)  # url 命名反转


  def login(request, location):
      return HttpResponse('登录页面, 登录地点是 %s' % location)
</code></pre>
<ul>
<li><code>http://localhost:8000/cms/</code> 跳转到 <code>http://localhost:8000/cms/login/深圳?next=/</code></li>
</ul>
<h2 id="十一-urls的-应用命名空间-与-实例命名空间">十一、 <code>urls</code>的 应用命名空间 与 实例命名空间</h2>
<ul>
<li>应用命名空间
<ul>
<li>可以在每个应用的 <code>urls.py</code> 通过 <code>app_name</code> 进行设置 (一般使用这种方式设置)</li>
</ul>
</li>
</ul>
<pre><code>app_name = 'cms'
</code></pre>
<ul>
<li>也可以在 <code>ROOT_URLCONF</code> 指定的 <code>urls.py</code> 中使用 <code>include</code> 时进行设置(不常用)</li>
</ul>
<pre><code>    # mysite/urls.py
    path('cms/', include(('cms.urls', 'cms'))),  # 引入 cms 模块的 urls.py 并设置应用命名空间 为 cms
</code></pre>
<ul>
<li>
<p>作用： 如上面的 <code>url</code> 命名反转时 <code>reverse('cms:login')</code>, 可以防止与其它应用的 <code>url</code> 命名冲突</p>
</li>
<li>
<p>实例命名空间</p>
<ul>
<li>在通过 <code>include</code> 引用时，进行设置</li>
</ul>
</li>
</ul>
<pre><code>    # 设置实例命名空间
    path('cms/', include('cms.urls', namespace='cms')),

    # 同时设置 应用命名空间 和 实例命名空间
    path('cms/', include(('cms.urls', 'cms'), namespace='cms')),
</code></pre>
<ul>
<li>
<p>作用： 当多个不同 <code>url</code> 指向同一个应用时， 防止 <code>url</code> 冲突</p>
<p><strong>不使用实例命名空间的情况</strong></p>
<ul>
<li>修改<code>mysite/urls.py</code></li>
</ul>
</li>
</ul>
<pre><code>      path('cms1/', include('cms.urls')),  # 不同的 url 指向同一个 应用
      path('cms2/', include('cms.urls')),
</code></pre>
<pre><code>* 访问 `http://localhost:8000/cms1/` 跳转到 `http://localhost:8000/cms1/login/深圳?next=/`  
* 访问 `http://localhost:8000/cms2/` 也跳转到 `http://localhost:8000/cms1/login/深圳?next=/`  

**冲突了吧！**

**使用实例命名空间**

* 修改`mysite/urls.py`
</code></pre>
<pre><code>    path('cms1/', include('cms.urls', namespace='cms1')),
    path('cms2/', include('cms.urls', namespace='cms2')),
</code></pre>
<pre><code>* 修改`mysite/views.py`
</code></pre>
<pre><code>def index(request):
      username = request.GET.get('username')
      if username:
          return HttpResponse('cms首页')
      else:
          # 重定向登录页面
          current_namespace = request.resolver_match.namespace
          login_url = reverse('%s:login' % current_namespace, kwargs={'location': '深圳'})  # url传参
          login_url += '?next=/'  # 查询字符串
          return redirect(login_url)  # url 命名反转
</code></pre>
<pre><code>* 访问 `http://localhost:8000/cms1/` 跳转到 `http://localhost:8000/cms1/login/深圳?next=/`  
* 访问 `http://localhost:8000/cms2/` 跳转到 `http://localhost:8000/cms2/login/深圳?next=/`
</code></pre>
<h2 id="十二-re_path-函数">十二、 <code>re_path</code> 函数</h2>
<blockquote>
<p>通过正则进行匹配参数</p>
</blockquote>
<p><strong>匹配生日</strong></p>
<ul>
<li>修改 <code>front/urls.py</code></li>
</ul>
<pre><code>  from django.urls import path, re_path
  from . import views

  app_name = 'front'

  urlpatterns = [
      path('', views.index, name='index'),
      # ?P&lt;birthday&gt; 表示参数为 birthday 匹配 \d{4}-\d{2}-\d{2}
      re_path(r'^birthday/(?P&lt;birthday&gt;\d{4}-\d{2}-\d{2})/$', views.index_birthday, name='birthday')
  ]
</code></pre>
<ul>
<li>修改 <code>front/views.py</code></li>
</ul>
<pre><code>  def index_birthday(request, birthday):
    return HttpResponse('生日快乐 %s' % birthday)
</code></pre>
<ul>
<li>
<p>访问： <code>http://localhost:8000/birthday/1992-12-28/</code></p>
</li>
<li>
<p>能用 <code>path</code> 解决的问题， 尽量不要用 <code>re_path</code> 因为 <code>re_path</code> 可读性差</p>
</li>
</ul>
<h2 id="十三-默认参数">十三、默认参数</h2>
<p><strong>要实现默认参数，需要两条 <code>url</code> 的配合</strong></p>
<ul>
<li>修改 <code>front/urls.py</code></li>
</ul>
<pre><code> from django.urls import path, re_path
 from . import views

 app_name = 'front'

 urlpatterns = [
     path('', views.index_list, name='index'),
     path('list/&lt;int:category_id&gt;', views.index_list, name='list'),
 ]
</code></pre>
<ul>
<li>修改 <code>front/views.py</code></li>
</ul>
<pre><code class="language-python">from django.http import HttpResponse
category = ['python', 'django', 'flask']

def index_list(request, category_id=0):
      return HttpResponse(category[category_id])
</code></pre>
<ul>
<li>
<p>访问： <code>http://localhost:8000</code>, 显示:<br>
<code>python</code></p>
</li>
<li>
<p>访问： <code>http://localhost:8000/list/2</code>, 显示：<br>
<code>flask</code></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django模板中加载静态文件]]></title>
        <id>https://xiong-zh.github.io/post/Django模板中加载静态文件</id>
        <link href="https://xiong-zh.github.io/post/Django模板中加载静态文件">
        </link>
        <updated>2020-01-18T13:11:05.000Z</updated>
        <summary type="html"><![CDATA[<p>Django模板中加载静态文件</p>
]]></summary>
        <content type="html"><![CDATA[<p>Django模板中加载静态文件</p>
<!-- more -->
<h1 id="模板中加载静态文件">模板中加载静态文件</h1>
<blockquote>
<p>接着 <a href="https://zhb333.github.io/readme-blog/Python/Django/templates_4.html">模板结构优化</a> 往下讲</p>
</blockquote>
<ul>
<li>
<p>确保<code>mysite/setting.py</code> 中 <code>INSTALLED_APPS</code> 已经安装了 <code>django.contrib.staticfiles</code></p>
</li>
<li>
<p>确保 <code>mysite/setting.py</code> 中设置了 <code>STATIC_URL</code></p>
</li>
<li>
<p>在已经安装的 <code>app</code> 下创建 <code>static</code> 文件夹，并将该应用的静态资源存放在里面 : <code>front/static/suolong.jpg</code></p>
<p><code>templates/index.html</code></p>
</li>
</ul>
<pre><code class="language-html">  {% block content %}
      &lt;img src=&quot;/static/suolong.jpg&quot; alt=&quot;suolong&quot;&gt;
  {% endblock %}
</code></pre>
<ul>
<li>
<p><code>mysite/setting.py</code> 中 <code>STATIC_URL</code> 值是可变的，这样以后引用静态资源的路径都要根据 <code>STATIC_URL</code> 是新值去修改，因此我们需要使用 <code>{% load static %}</code></p>
<p><code>templates/index.html</code></p>
</li>
</ul>
<pre><code>  {% extends 'base.html' %}
  {% load static %}

  {% block content %}
      &lt;img src=&quot;{% static 'suolong.jpg' %}&quot; alt=&quot;suolong&quot;&gt;
  {% endblock %}
</code></pre>
<ul>
<li>
<p>公共资源路径</p>
<p>在更目录下创建 <code>static</code> 文件夹</p>
<p><code>static/style.css</code></p>
</li>
</ul>
<pre><code>  body {
      background-color: #abcdef;
  }
</code></pre>
<p><code>mysite/setting.py</code></p>
<pre><code>  STATICFILES_DIRS = (
      os.path.join(BASE_DIR, 'static'),
  )
</code></pre>
<p><code>mysite/base.html</code></p>
<pre><code>  {% load static %}
  &lt;!DOCTYPE html&gt;
  &lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
      &lt;meta charset=&quot;UTF-8&quot;&gt;
      &lt;title&gt;Title&lt;/title&gt;
      &lt;link rel=&quot;stylesheet&quot; href=&quot;{% static 'style.css' %}&quot;&gt;
  &lt;/head&gt;
</code></pre>
<ul>
<li>
<p>在每个需要加载静态资源文件的模板中都要写 <code>{% load static %}</code>, 为了不在每个模板中都写，我们可以吧 <code>static</code> 变为 <code>DTL</code> 模板标签</p>
<p><code>mysite/setting.py</code></p>
</li>
</ul>
<pre><code>  TEMPLATES = [
      {
        'OPTIONS': {
            'builtins': [
                'django.templatetags.static'
            ]
        },
      },
  ]
</code></pre>
<p><strong>这样就不用在每个页面中引入<code>{% load static %}</code></strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django模板结构优化]]></title>
        <id>https://xiong-zh.github.io/post/Django模板结构优化</id>
        <link href="https://xiong-zh.github.io/post/Django模板结构优化">
        </link>
        <updated>2020-01-18T13:09:55.000Z</updated>
        <summary type="html"><![CDATA[<p>Django模板结构优化</p>
]]></summary>
        <content type="html"><![CDATA[<p>Django模板结构优化</p>
<!-- more -->
<h1 id="dtl-模板结构优化"><code>DTL</code> 模板结构优化</h1>
<h2 id="一-引入模板">一、引入模板</h2>
<h3 id="include-标签的使用"><code>include</code> 标签的使用</h3>
<ul>
<li>
<p>新建 <code>templates/header.html</code></p>
<pre><code>&lt;header&gt;头部&lt;/header&gt;
</code></pre>
</li>
<li>
<p>新建 <code>templates/footer.html</code></p>
<pre><code>&lt;footer&gt;尾部&lt;/footer&gt;
</code></pre>
</li>
<li>
<p>修改 <code>templates/index.html</code></p>
</li>
</ul>
<pre><code>    &lt;body&gt;
    {% include 'header.html' %}
    &lt;div&gt;内容&lt;/div&gt;
    {% include 'footer.html' %}
    &lt;/body&gt;
</code></pre>
<h3 id="include-标签中的模板查找路径"><code>include</code> 标签中的模板查找路径</h3>
<p><strong>参照 <a href="http://localhost:8080/readme-blog/Python/Django/templates_1.html#%E4%B8%80%E3%80%81%E6%A8%A1%E6%9D%BF%E6%9F%A5%E6%89%BE%E8%B7%AF%E5%BE%84">render_to_string的模板查找路径</a></strong></p>
<h3 id="include-标签引入的模板可以引用当前模板中的变量"><code>include</code> 标签引入的模板可以引用当前模板中的变量</h3>
<ul>
<li>修改 <code>front/views.py</code></li>
</ul>
<pre><code>    def index(request):
        context = {
            'title': 'Django'
        }
        return render(request, 'index.html', context=context)
</code></pre>
<ul>
<li>
<p>修改 <code>templates/header.html</code></p>
<pre><code>{#头部 Django#}
&lt;header&gt;头部 {{ title }}&lt;/header&gt;
</code></pre>
</li>
<li>
<p>但为了所有引用 <code>templates/header.html</code> 的模板都能使用 <code>title</code> 变量， 可以在 <code>include</code> 标签中传递该变量</p>
<p>修改 <code>templates/index.html</code></p>
<pre><code>{#头部 Young and Beautiful#}
{% include 'header.html' with title='Young and Beautiful' %}
</code></pre>
</li>
</ul>
<h2 id="二-模板继承">二、模板继承</h2>
<ul>
<li>新建 <code>templates/base.html</code>：</li>
</ul>
<pre><code>    &lt;body&gt;
    {% include 'header.html' with title='Young and Beautiful' %}
    &lt;div&gt;
        {% block content %}
            默认内容
        {% endblock %}
    &lt;/div&gt;
    {% include 'footer.html' %}
    &lt;/body&gt;
</code></pre>
<ul>
<li>修改 <code>templates/index.html</code>:</li>
</ul>
<pre><code>    {% extends 'base.html' %}

    {% block content %}
    首页中的内容
    {% endblock %}
</code></pre>
<ul>
<li>
<p>访问 <code>block</code> 标签被覆盖的内容：</p>
<p><code>templates/index.html</code>:</p>
</li>
</ul>
<pre><code>    {% extends 'base.html' %}

    {% block content %}
    首页中的内容
    &lt;p&gt;{{ block.super }}&lt;/p&gt;
    {% endblock %}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django自定义模板过滤器]]></title>
        <id>https://xiong-zh.github.io/post/Django自定义模板过滤器</id>
        <link href="https://xiong-zh.github.io/post/Django自定义模板过滤器">
        </link>
        <updated>2020-01-18T13:08:18.000Z</updated>
        <summary type="html"><![CDATA[<p>Django自定义模板过滤器</p>
]]></summary>
        <content type="html"><![CDATA[<p>Django自定义模板过滤器</p>
<!-- more -->
<h1 id="dtl-自定义模板过滤器"><code>DTL</code> 自定义模板过滤器</h1>
<h2 id="一-模板过滤器的定义">一、模板过滤器的定义</h2>
<ul>
<li>
<p>在应用的目录下，如 <code>front</code> 下， 新建一个名为： <code>templatetags</code> 的 <code>python</code> 包</p>
</li>
<li>
<p>新建 <code>front/templatetags/custom_filter.py</code>, 并定义两个模板过滤器如下：</p>
</li>
</ul>
<pre><code>  from django import template

  register = template.Library()


  def my_add(value, arg):
      try:
          return value + arg
      except (Exception,):
          return ''


  def my_upper(value):
      try:
          return value.upper()
      except (Exception,):
          return value


  register.filter('my_add', my_add)
  register.filter('my_upper', my_upper)
</code></pre>
<ul>
<li>
<p>需要使用 <code>{% load custom_filter %}</code>, 把应用下定义模板过滤器的文件导入模板</p>
</li>
<li>
<p><code>templates/index.html</code> 代码修改如下：</p>
</li>
</ul>
<pre><code>  {% load custom_filter %}
  &lt;!DOCTYPE html&gt;
  &lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
      &lt;meta charset=&quot;UTF-8&quot;&gt;
      &lt;title&gt;Title&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
  {#abcdef#}
  {{ &quot;abc&quot;|my_add:&quot;def&quot; }} &lt;br&gt;
  {#HELLO#}
  {{ &quot;hello&quot;|my_upper }}
  &lt;/body&gt;
  &lt;/html&gt;
</code></pre>
<ul>
<li>*<em>注意，<code>front</code> 应用必须在 <code>mysite/settings.py</code> 进行注册，在 <code>front</code> 下定义的模板过滤器才能起作用</em></li>
</ul>
<pre><code>  INSTALLED_APPS = [
      'front',
  ]
</code></pre>
<h2 id="二-实战-自定义时间计算过滤器">二、实战--自定义时间计算过滤器</h2>
<p><code>front/templatetags/custom_filter.py</code></p>
<pre><code>from django import template
from datetime import datetime

register = template.Library()


@register.filter
def time_since(value):
    &quot;&quot;&quot;
    time距离现在的时间间隔
    1 如果时间间隔小于1分钟，那么显示 刚刚
    2 如果时间间隔大于1分钟小于1小时， 那么显示 xx 分钟前
    3 如果是大于1小时小于24小时，那么显示 xx 小时前
    4 如果大于24小时，小于30天， 那么显示 xx 天前
    5 否则显示具体时间， 2018/12/10 23:05
    &quot;&quot;&quot;
    if not isinstance(value, datetime):
        return value
    now = datetime.now()
    timestamp = (now - value).total_seconds()
    if timestamp &lt; 60:
        return '刚刚'
    elif 60 &lt;= timestamp &lt; 60 * 60:
        minutes = int(timestamp/60)
        return '%s分钟前' % minutes
    elif 60 * 60 &lt;= timestamp &lt; 60 * 60 * 24:
        hour = int(timestamp / (60 * 60))
        return '%s 小时前' % hour
    elif 60 * 60 * 24 &lt;= timestamp &lt; 60 * 60 * 24 * 30:
        days = int(timestamp / (60 * 60 * 24))
        return '%s 天前' % days
    else:
        return value.strftime(&quot;%Y/%m/%d %H:%M&quot;)
</code></pre>
<p><code>front/views.py</code></p>
<pre><code>from django.shortcuts import render
from datetime import datetime


def index(request):
    context = {
        'my_time_1': datetime.now(),
        'my_time_2': datetime(year=2018, month=12, day=10, hour=23, minute=18),
        'my_time_3': datetime(year=2018, month=12, day=10, hour=18, minute=18),
        'my_time_4': datetime(year=2018, month=12, day=1, hour=22, minute=18),
        'my_time_5': datetime(year=2017, month=12, day=10, hour=23, minute=18),
    }
    return render(request, 'index.html', context=context)
</code></pre>
<p><code>templates/index.html</code></p>
<pre><code>{% load custom_filter %}
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
{#刚刚 #}
{{ my_time_1|time_since }} &lt;br&gt;
{#7分钟前 #}
{{ my_time_2|time_since }} &lt;br&gt;
{#5 小时前 #}
{{ my_time_3|time_since }} &lt;br&gt;
{#9 天前 #}
{{ my_time_4|time_since }} &lt;br&gt;
{#2017/12/10 23:18#}
{{ my_time_5|time_since }}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django模板过滤器详解]]></title>
        <id>https://xiong-zh.github.io/post/Django模板过滤器详解</id>
        <link href="https://xiong-zh.github.io/post/Django模板过滤器详解">
        </link>
        <updated>2020-01-18T13:06:44.000Z</updated>
        <summary type="html"><![CDATA[<p>Django模板过滤器详解</p>
]]></summary>
        <content type="html"><![CDATA[<p>Django模板过滤器详解</p>
<!-- more -->
<h1 id="dtl-模板过滤器"><code>DTL</code> 模板过滤器</h1>
<h2 id="add"><code>add</code></h2>
<ul>
<li>原理：</li>
</ul>
<pre><code>  def add(value, arg):
    &quot;&quot;&quot;Add the arg to the value&quot;&quot;&quot;
    try:
      return int(value) + int(arg)
    except (ValueError, TypeError):
      try:
        return value + arg
      except Exception:
        return ''
</code></pre>
<ul>
<li>使用<br>
<code>front/views.py</code></li>
</ul>
<pre><code>  def index(request):
    context = {
        &quot;number&quot;: 1,
        &quot;persons&quot;: ['baby', 'dear'],
        &quot;girls&quot;: ['宝宝', '亲爱的']
    }
    return render(request, 'index.html', context=context)
</code></pre>
<p><code>templates/index.html</code></p>
<pre><code>{#数字相加#}
{{ number|add:&quot;2&quot; }} &lt;br&gt;
{#字符串拼接#}
{{ number|add:'abc' }} &lt;br&gt;
{#列表拼接#}
{{ persons|add:girls }}
</code></pre>
<h2 id="cut"><code>cut</code></h2>
<ul>
<li>
<p>原理：</p>
<pre><code>def cut(vaule, arg):
  &quot;&quot;&quot;Remove all values of arg from the given string&quot;&quot;&quot;
  safe = isinstance(value, SafeData)
  value = value.replace(arg, '')
  if safe and arg != ';':
    return mark_safe(value)
  return value
</code></pre>
</li>
<li>
<p>使用<br>
<code>templates/index.html</code></p>
<pre><code>{# 去除字符串中空格 #}
{{ &quot;This is ten percent luck, twenty percent skill&quot;|cut:&quot; &quot; }}
</code></pre>
</li>
</ul>
<h2 id="date"><code>date</code></h2>
<ul>
<li>
<p>所有格式</p>
<table>
<thead>
<tr>
<th style="text-align:center">格式字符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">示例输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">'a.m.' 或 'p.m.' （请注意，这与PHP输出略有不同，因为这包括与Associated Press样式匹配的句点。）</td>
<td style="text-align:center">'a.m.'</td>
</tr>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">'AM' 或 'PM'。</td>
<td style="text-align:center">'a.m.'</td>
</tr>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:center">月，文字，3个字母，小写。</td>
<td style="text-align:center">'jan'</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">未实现。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:center">ISO 8601格式。 （注意：与其他格式化程序，如“Z”，“O”或“r”不同，如果值是一个天真的datetime（见 datetime.tzinfo），“c”格式化程序不会添加时区偏移。</td>
<td style="text-align:center">2008-01-02T10:30:00.000123+02:00 或 2008-01-02T10:30:00.000123 （如果datetime是天真的）</td>
</tr>
<tr>
<td style="text-align:center">d</td>
<td style="text-align:center">月的日期，带前导零的2位数字。</td>
<td style="text-align:center">'01' 到 '31'</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">星期几，文字，3个字母。</td>
<td style="text-align:center">'Fri'</td>
</tr>
<tr>
<td style="text-align:center">e</td>
<td style="text-align:center">时区名称。可以是任何格式，或可能返回一个空字符串，具体取决于datetime。</td>
<td style="text-align:center">''，'GMT'，'-500'，'US/Eastern' 等。</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">月，特定于语言环境的替代表示，通常用于长日期表示。</td>
<td style="text-align:center">'listopada' （对于波兰语区域，而不是 'Listopad'）</td>
</tr>
<tr>
<td style="text-align:center">f</td>
<td style="text-align:center">时间，12小时小时和分钟，如果他们为零，分钟将关闭。专有扩展。</td>
<td style="text-align:center">'1'，'1:30'</td>
</tr>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">月，文字，长。</td>
<td style="text-align:center">'January'</td>
</tr>
<tr>
<td style="text-align:center">g</td>
<td style="text-align:center">小时，12小时格式，不含前导零。</td>
<td style="text-align:center">'1' 到 '12'</td>
</tr>
<tr>
<td style="text-align:center">G</td>
<td style="text-align:center">小时，24小时格式，无前导零。</td>
<td style="text-align:center">'0' 到 '23'</td>
</tr>
<tr>
<td style="text-align:center">h</td>
<td style="text-align:center">小时，12小时格式。</td>
<td style="text-align:center">'01' 到 '12'</td>
</tr>
<tr>
<td style="text-align:center">H</td>
<td style="text-align:center">小时，24小时格式。</td>
<td style="text-align:center">'00' 到 '23'</td>
</tr>
<tr>
<td style="text-align:center">i</td>
<td style="text-align:center">分钟。</td>
<td style="text-align:center">'00' 到 '59'</td>
</tr>
<tr>
<td style="text-align:center">I</td>
<td style="text-align:center">夏令时，无论是否生效。</td>
<td style="text-align:center">'1' 或 '0'</td>
</tr>
<tr>
<td style="text-align:center">j</td>
<td style="text-align:center">没有前导零的月份日。</td>
<td style="text-align:center">'1' 到 '31'</td>
</tr>
<tr>
<td style="text-align:center">l</td>
<td style="text-align:center">星期几，文字，长。</td>
<td style="text-align:center">'Friday'</td>
</tr>
<tr>
<td style="text-align:center">L</td>
<td style="text-align:center">是否为闰年的布尔值。</td>
<td style="text-align:center">True 或 False</td>
</tr>
<tr>
<td style="text-align:center">m</td>
<td style="text-align:center">月，2位数字，前导零。</td>
<td style="text-align:center">'01' 到 '12'</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">月，文字，3个字母。</td>
<td style="text-align:center">'Jan'</td>
</tr>
<tr>
<td style="text-align:center">n</td>
<td style="text-align:center">没有前导零的月。</td>
<td style="text-align:center">'1' 到 '12'</td>
</tr>
<tr>
<td style="text-align:center">N</td>
<td style="text-align:center">月缩写在Associated Press风格。专有扩展。</td>
<td style="text-align:center">'Jan.'，'Feb.'，'March'，'May'</td>
</tr>
<tr>
<td style="text-align:center">o</td>
<td style="text-align:center">ISO-8601周编号年，对应于使用闰年的ISO-8601周编号（W）。更常见的年份格式见Y。</td>
<td style="text-align:center">'1999'</td>
</tr>
<tr>
<td style="text-align:center">O</td>
<td style="text-align:center">与格林威治时间的差值（以小时为单位）。</td>
<td style="text-align:center">'+0200'</td>
</tr>
<tr>
<td style="text-align:center">P</td>
<td style="text-align:center">时间，12小时制，分钟和’a.m。’/’p.m。’，如果它们为零，分钟将关闭，如果合适，分钟将保留特殊字符串’午夜’和’中午’。专</td>
<td style="text-align:center">有扩展。 '1 a.m.'，'1:30 p.m.'，'midnight'，'noon'，'12:30 p.m.'</td>
</tr>
<tr>
<td style="text-align:center">r</td>
<td style="text-align:center">RFC 5322 格式的日期。</td>
<td style="text-align:center">'Thu, 21 Dec 2000 16:01:07 +0200'</td>
</tr>
<tr>
<td style="text-align:center">s</td>
<td style="text-align:center">秒，带前导零的2位数。</td>
<td style="text-align:center">'00' 到 '59'</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">每月日期的英文序数后缀，2个字符。</td>
<td style="text-align:center">'st'，'nd'，'rd' 或 'th'</td>
</tr>
<tr>
<td style="text-align:center">t</td>
<td style="text-align:center">指定月份的天数。</td>
<td style="text-align:center">28 到 31</td>
</tr>
<tr>
<td style="text-align:center">T</td>
<td style="text-align:center">本机的时区。</td>
<td style="text-align:center">'EST'，'MDT'</td>
</tr>
<tr>
<td style="text-align:center">u</td>
<td style="text-align:center">微秒。</td>
<td style="text-align:center">000000 到 999999</td>
</tr>
<tr>
<td style="text-align:center">U</td>
<td style="text-align:center">自Unix时代以来的秒数（1970年1月1日00:00:00 UTC）。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td style="text-align:center">星期几，没有前导零的数字。</td>
<td style="text-align:center">'0' （星期日）至 '6' （星六）</td>
</tr>
<tr>
<td style="text-align:center">W</td>
<td style="text-align:center">ISO-8601年的周数，周从星期一开始。</td>
<td style="text-align:center">1，53</td>
</tr>
<tr>
<td style="text-align:center">y</td>
<td style="text-align:center">年，2位数。</td>
<td style="text-align:center">'99'</td>
</tr>
<tr>
<td style="text-align:center">Y</td>
<td style="text-align:center">年，4位数。</td>
<td style="text-align:center">'1999'</td>
</tr>
<tr>
<td style="text-align:center">z</td>
<td style="text-align:center">一年中的一天。</td>
<td style="text-align:center">0 到 365</td>
</tr>
<tr>
<td style="text-align:center">Z</td>
<td style="text-align:center">时区偏移（以秒为单位）。 UTC之前的时区的偏移总是负的，并且对于UTC的东部的偏移总是正的。</td>
<td style="text-align:center">-43200 到 43200</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>常用格式</p>
<table>
<thead>
<tr>
<th style="text-align:center">格式字符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">示例输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Y</td>
<td style="text-align:center">年，4位数。</td>
<td style="text-align:center">'1999'</td>
</tr>
<tr>
<td style="text-align:center">m</td>
<td style="text-align:center">月，2位数字，前导零。</td>
<td style="text-align:center">'01' 到 '12'</td>
</tr>
<tr>
<td style="text-align:center">n</td>
<td style="text-align:center">没有前导零的月。</td>
<td style="text-align:center">'1' 到 '12'</td>
</tr>
<tr>
<td style="text-align:center">d</td>
<td style="text-align:center">月的日期，带前导零的2位数字。</td>
<td style="text-align:center">'01' 到 '31'</td>
</tr>
<tr>
<td style="text-align:center">j</td>
<td style="text-align:center">没有前导零的月份日。</td>
<td style="text-align:center">'1' 到 '31'</td>
</tr>
<tr>
<td style="text-align:center">g</td>
<td style="text-align:center">小时，12小时格式，不含前导零。</td>
<td style="text-align:center">'1' 到 '12'</td>
</tr>
<tr>
<td style="text-align:center">h</td>
<td style="text-align:center">小时，12小时格式。</td>
<td style="text-align:center">'01' 到 '12'</td>
</tr>
<tr>
<td style="text-align:center">G</td>
<td style="text-align:center">小时，24小时格式，无前导零。</td>
<td style="text-align:center">'0' 到 '23'</td>
</tr>
<tr>
<td style="text-align:center">H</td>
<td style="text-align:center">小时，24小时格式。</td>
<td style="text-align:center">'00' 到 '23'</td>
</tr>
<tr>
<td style="text-align:center">i</td>
<td style="text-align:center">分钟。</td>
<td style="text-align:center">'00' 到 '59'</td>
</tr>
<tr>
<td style="text-align:center">s</td>
<td style="text-align:center">秒，带前导零的2位数。</td>
<td style="text-align:center">'00' 到 '59'</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p><code>front/views.py</code></p>
<pre><code>from django.shortcuts import render
from datetime import datetime


def index(request):
    context = {
        &quot;today&quot;: datetime.now()
    }
    return render(request, 'index.html', context=context)
</code></pre>
<p><code>templates/index.html</code></p>
<pre><code>{# 2018/12/09 #}
{{ today|date:&quot;Y/m/d&quot; }}
</code></pre>
<h2 id="default"><code>default</code></h2>
<p><code>front/views.py</code></p>
<pre><code>from django.shortcuts import render


def index(request):
    context = {
        'list': [],
        'dict': {},
        'str': '',
        'none': None,
        'number': 0,
    }
    return render(request, 'index.html', context=context)
</code></pre>
<p><code>templates/index.html</code></p>
<pre><code>{# 空列表 #}
{{ list|default:'空列表' }}
{#空字典#}
{{ dict|default:'空字典' }}
{#空字符串#}
{{ str|default:'空字符串' }}
{#数字0#}
{{ number|default:'数字0' }}
{#None#}
{{ none|default:'None' }}
</code></pre>
<h2 id="default-if-none"><code>default-if-none</code></h2>
<p><strong>只有值为<code>None</code>才会起作用</strong></p>
<p><code>templates/index.html</code></p>
<pre><code>{#[]#}
{{ list|default_if_none:'空字典' }}
{{ str|default_if_none:'空字符串' }}
{#0#}
{{ number|default_if_none:'数字0' }}
{#None#}
{{ none|default_if_none:'None' }}
</code></pre>
<h2 id="first"><code>first</code></h2>
<p><strong>返回列表或元组中的第一个元素</strong></p>
<p><code>front/views.py</code></p>
<pre><code>from django.shortcuts import render


def index(request):
    context = {
        'student': ['威震天', '擎天柱']
    }
    return render(request, 'index.html', context=context)
</code></pre>
<p><code>templates/index.html</code></p>
<pre><code>{# 威震天 #}
{{ student|first }}
</code></pre>
<h2 id="last"><code>last</code></h2>
<p><strong>返回列表或元组中的最后一个元素</strong></p>
<p><code>templates/index.html</code></p>
<pre><code>{# 擎天柱 #}
{{ student|last }}
</code></pre>
<h2 id="floatformat"><code>floatformat</code></h2>
<p><strong>四舍五入格式化浮点类型</strong></p>
<ul>
<li>
<p>没有参数是，默认保留一位小数点</p>
</li>
<li>
<p>传递的参数代表小数点的位数</p>
</li>
</ul>
<p><code>templates/index.html</code></p>
<pre><code>{#3.1#}
{{ 3.141592654|floatformat }} &lt;br&gt;
{#3.14159 #}
{{ 3.141592654|floatformat:5 }} &lt;br&gt;
</code></pre>
<h2 id="join"><code>join</code></h2>
<p><strong>指定分隔符把元组或者列表，转换为字符串</strong></p>
<p><code>templates/index.html</code></p>
<pre><code>{#威震天-擎天柱#}
{{ student|join:'-' }}
</code></pre>
<h2 id="length"><code>length</code></h2>
<p><strong>返回元组、列表、字符串的长度</strong><br>
<code>templates/index.html</code></p>
<pre><code>{#2#}
{{ student|length }}
</code></pre>
<h2 id="lower"><code>lower</code></h2>
<p><strong>将字符串转换为小写</strong><br>
<code>templates/index.html</code></p>
<pre><code>{#abc#}
{{ &quot;ABC&quot;|lower }}
</code></pre>
<h2 id="upper"><code>upper</code></h2>
<p><strong>将字符串转换为大写</strong><br>
<code>templates/index.html</code></p>
<pre><code>{#ABC#}
{{ &quot;abc&quot;|upper }}
</code></pre>
<h2 id="random"><code>random</code></h2>
<p><strong>返回元组、列表、字符串中随机选取一个值</strong><br>
<code>templates/index.html</code></p>
<pre><code>{{ &quot;abc&quot;|random }}
</code></pre>
<h2 id="safe"><code>safe</code></h2>
<p><strong>标记一个字符串是安全的，包含特殊字符，也不会被转义， 类似关闭<code>autoescape</code>标签的自动转义</strong><br>
<code>templates/index.html</code></p>
<pre><code>{{ &quot;&lt;h1&gt;autoescape off&lt;/h1&gt;&quot;|safe }}
</code></pre>
<h2 id="slice"><code>slice</code></h2>
<p><strong>类似于<code>python</code>的切片操作</strong></p>
<p><code>front/views.py</code></p>
<pre><code>def index(request):
    context = {
        'data': list(range(10))
    }
    return render(request, 'index.html', context=context)
</code></pre>
<p><code>templates/index.html</code></p>
<pre><code>{#[1, 3, 5, 7, 9]#}
{{ data|slice:&quot;1::2&quot;}}
</code></pre>
<h2 id="striptags"><code>striptags</code></h2>
<p><strong>去除字符串中的 <code>HTML</code> 标签</strong></p>
<p><code>templates/index.html</code></p>
<pre><code>{{ &quot;&lt;h1&gt;去除字符串中的html标签&lt;/h1&gt;&quot;|striptags }}
</code></pre>
<h2 id="truncatechars"><code>truncatechars</code></h2>
<p><strong>显示指定字符长度，超出部分显示..., 三个点也纳入指定字符范围的长度</strong></p>
<p><code>templates/index.html</code></p>
<pre><code>{#显示...#}
{{ &quot;显示指定字符长度，超出部分显示...&quot;|truncatechars:5 }}
</code></pre>
<h2 id="truncatechars_html"><code>truncatechars_html</code></h2>
<p><strong>类似 <code>truncatechars</code>, 只不过不会切割 <code>HTML</code> 标签</strong><br>
<code>templates/index.html</code></p>
<pre><code>{{ &quot;&lt;h1&gt;显示指定字符长度，超出部分显示...&lt;/h1&gt;&quot;|truncatechars_html:5 }}
</code></pre>
<h2 id="其它不常用过滤器">其它不常用过滤器</h2>
<p><strong>可以在 <code>pycharm</code> 中， 查看源代码</strong></p>
<pre><code>from django.template import defaultfilters, defaulttags
# defaultfilters 查看内置过滤器
# defaulttags 查看内置标签
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django 模板标签详解]]></title>
        <id>https://xiong-zh.github.io/post/Django模板标签详解</id>
        <link href="https://xiong-zh.github.io/post/Django模板标签详解">
        </link>
        <updated>2020-01-18T13:05:34.000Z</updated>
        <summary type="html"><![CDATA[<p>Django 模板标签详解</p>
]]></summary>
        <content type="html"><![CDATA[<p>Django 模板标签详解</p>
<!-- more -->
<h1 id="dtl-模板标签详解"><code>DTL</code> 模板标签详解</h1>
<blockquote>
<p>接着上一篇 <a href="https://zhb333.github.io/readme-blog/Python/Django/urls.html" title="urls与视图详解">urls与视图详解</a> 继续往下讲</p>
</blockquote>
<h2 id="一-模板查找路径">一、模板查找路径</h2>
<p><code>mysite/setting.py</code>： 模板查找的优先级最高为如下配置</p>
<pre><code>TEMPLATES = [
    {
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
    },
]
</code></pre>
<p>其次是，在各自的 <code>app</code> 中， 注意， 需要在 <code>INSTALLED_APPS</code> 中注册后才能起作用：</p>
<pre><code>INSTALLED_APPS = [
    'front',
]

TEMPLATES = [
    {
        'APP_DIRS': True,
    },
]
</code></pre>
<p>最后如果在当前 <code>app</code> 中还找不到模板，会到其它已安装的 <code>app</code> 中查找， 如果还找不到就会报错了！</p>
<h2 id="二-render_to_string">二、<code>render_to_string</code></h2>
<ul>
<li>
<p>在根目录新建 <code>templates</code> 文件夹</p>
</li>
<li>
<p>创建 <code>templates/index.html</code></p>
</li>
</ul>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        body {
            color: #f00;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
佛曰： 我执， 是痛苦的根源！
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>修改 <code>front/urls.py</code></li>
</ul>
<pre><code> path('', views.index, name='index'),
</code></pre>
<ul>
<li>修改 <code>front/views.py</code></li>
</ul>
<pre><code>from django.template.loader import render_to_string
from django.http import HttpResponse


def index(request):
    # 在 mysite/settings.py 配置了项目模板路径
    html = render_to_string(&quot;index.html&quot;)
    return HttpResponse(html)
</code></pre>
<h2 id="三-render">三、<code>render</code></h2>
<blockquote>
<p><code>render_to_string</code> 与 <code>HttpResponse</code> 组合的快捷方式， 可 <code>pycharm</code> 查看 <code>render</code> 的实现如下：</p>
</blockquote>
<pre><code>def render(request, template_name, context=None, content_type=None, status=None, using=None):
    content = loader.render_to_string(template_name, context, request, using=using)
    return HttpResponse(content, content_type, status)
</code></pre>
<p>修改 <code>front/views.py</code></p>
<pre><code>from django.shortcuts import render


def index(request):
    return render(request, 'index.html')
</code></pre>
<h2 id="四-模板变量">四、模板变量</h2>
<blockquote>
<p>可以通过<code>render</code> 函数的 <code>context</code> 参数，给模板传递数据</p>
</blockquote>
<p><strong>模板中，不支持中括号语法，只能通过 <code>.</code> 语法获取</strong></p>
<ul>
<li>
<p>传递字符串</p>
<p>修改 <code>front/views.py</code></p>
</li>
</ul>
<pre><code>def index(request):
    context = {'username': 'zhb333'}
    return render(request, 'index.html', context=context)
</code></pre>
<pre><code>修改 `templates/index.html`
</code></pre>
<pre><code>    &lt;body&gt;
    {{ username }}
    &lt;/body&gt;
</code></pre>
<pre><code>访问：`http://localhost:8000/`, 页面显示： **zhb333**
</code></pre>
<ul>
<li>
<p>传递一个对象</p>
<p>修改 <code>front/views.py</code></p>
</li>
</ul>
<pre><code>class Person:
   def __init__(self, username):
        self.username = username


   def index(request):
        context = {'person': Person('理想三旬')}
        return render(request, 'index.html', context=context)
</code></pre>
<pre><code>修改 `templates/index.html`
</code></pre>
<pre><code>  {{ person.username }}
</code></pre>
<ul>
<li>
<p>传递的数据是一个字典时， 字典中不要出现关键字，这样会造成歧义</p>
<p>修改 <code>front/views.py</code></p>
</li>
</ul>
<pre><code>    def index(request):
        context = {'person': {'username': '我要你'}}
        return render(request, 'index.html', context=context)
</code></pre>
<pre><code>修改 `templates/index.html`  
</code></pre>
<pre><code>   {{ person.keys }}
</code></pre>
<pre><code>浏览器显示： **dict_keys(['username'])**  

修改 `front/views.py`
</code></pre>
<pre><code>def index(request):
     context = {'person': {'username': '我要你', 'keys': '夜空中最亮的星'}}
     return render(request, 'index.html', context=context)
</code></pre>
<pre><code>浏览器显示： **夜空中最亮的星**
</code></pre>
<ul>
<li>
<p>传递列表或元组</p>
<p>修改 <code>front/views.py</code></p>
</li>
</ul>
<pre><code>   # context = {'persons': ['那些花儿', '她们都老了吧', '她们在哪里呀']}
   context = {'persons': ('那些花儿', '她们都老了吧', '她们在哪里呀')}
</code></pre>
<pre><code>修改 `templates/index.html`  
</code></pre>
<pre><code>   {{ persons.0 }} &lt;br&gt;
   {{ persons.1 }} &lt;br&gt;
   {{ persons.2 }} &lt;br&gt;
</code></pre>
<h2 id="五-常用的模板标签">五 常用的模板标签</h2>
<p><strong>所有标签都需要用 <code>{%%}</code> 进行包裹</strong></p>
<ul>
<li><code>if</code> 标签
<blockquote>
<p><code>if</code> 标签中可以使用： <code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>in</code>、<code>not in</code>、<code>is</code>、<code>is not</code> 等判断运算符</p>
</blockquote>
<ul>
<li>
<p><code>if...else</code> 运算符举例</p>
<p>修改 <code>templates/index.html</code></p>
</li>
</ul>
</li>
</ul>
<pre><code>        {% if '那些花儿' in persons %}
            &lt;p style=&quot;color: hotpink&quot;&gt;可爱的花儿&lt;/p&gt;
        {% else %}
            &lt;p style=&quot;color: darkgray&quot;&gt;可伶的花儿&lt;/p&gt;
        {% endif %}
</code></pre>
<pre><code>* `if...elif...else` 举例
 修改 `templates/index.html`
</code></pre>
<pre><code>      {% if age &lt; 18 %}
            &lt;p&gt;乳臭未干的小子&lt;/p&gt;
      {% elif age == 18 %}
            &lt;p&gt;恰逢少年时&lt;/p&gt;
      {% else %}
            &lt;p&gt;老男人&lt;/p&gt;
      {% endif %}
</code></pre>
<ul>
<li>
<p><code>for...in</code> 循环列表</p>
<ul>
<li>
<p>循环列表</p>
<p>修改 <code>front/views.py</code></p>
</li>
</ul>
</li>
</ul>
<pre><code>    context = {
            'books': ['深入理解ES6', 'JavaScript权威指南', 'JavaScript语言精粹']
         }
</code></pre>
<pre><code>    修改 `templates/index.html`  
</code></pre>
<pre><code>    &lt;ul&gt;
       {% for book in books %}
             &lt;li&gt;{{ book }}&lt;/li&gt;
       {% endfor %}
    &lt;/ul&gt;
</code></pre>
<pre><code>* 反向循环列表  `reversed`

    修改 `templates/index.html`  
</code></pre>
<pre><code>     {% for book in books reversed %}
        &lt;li&gt;{{ book }}&lt;/li&gt;
     {% endfor %}
</code></pre>
<ul>
<li>
<p><code>for...in</code> 循环中， <code>DTL</code> 提供了一些可用的模板变量：</p>
<ul>
<li>
<p>列表的下标 <code>forloop.counter</code> 从 <code>1</code> 开始</p>
<p>修改 <code>templates/index.html</code></p>
</li>
</ul>
</li>
</ul>
<pre><code>   {% for book in books %}
      &lt;li&gt;{{ forloop.counter }} -- {{ book }}&lt;/li&gt;
   {% endfor %}
</code></pre>
<pre><code>* 列表的下标 `forloop.counter0` 从 `0` 开始

    修改 `templates/index.html`  
</code></pre>
<pre><code>        {% for book in books %}
            &lt;li&gt;{{ forloop.counter0 }} -- {{ book }}&lt;/li&gt;
        {% endfor %}
</code></pre>
<pre><code>* 列表的反向下标 `forloop.revcounter` 从 `1` 开始
</code></pre>
<pre><code>        {% for book in books reversed %}
            &lt;li&gt;{{ forloop.revcounter }} -- {{ book }}&lt;/li&gt;
        {% endfor %}
</code></pre>
<pre><code>* 列表的反向下标 `forloop.revcounter0` 从 `0` 开始
</code></pre>
<pre><code>        {% for book in books reversed %}
            &lt;li&gt;{{ forloop.revcounter0 }} -- {{ book }}&lt;/li&gt;
        {% endfor %}
</code></pre>
<pre><code>* 是否是第一次遍历 `forloop.first`
</code></pre>
<pre><code>        {% for book in books %}
            {% if forloop.first %}
                &lt;li style=&quot;color: green;&quot;&gt;{{ forloop.revcounter0 }} -- {{ book }}&lt;/li&gt;
            {% else %}
                &lt;li style=&quot;color: red;&quot;&gt;{{ forloop.revcounter0 }} -- {{ book }}&lt;/li&gt;
            {% endif %}
        {% endfor %}
</code></pre>
<pre><code>* 是否是最后一次次遍历 `forloop.last`
</code></pre>
<pre><code>        {% for book in books %}
            {% if forloop.last %}
                &lt;li style=&quot;color: green;&quot;&gt;{{ forloop.revcounter0 }} -- {{ book }}&lt;/li&gt;
            {% else %}
                &lt;li style=&quot;color: red;&quot;&gt;{{ forloop.revcounter0 }} -- {{ book }}&lt;/li&gt;
            {% endif %}
        {% endfor %}
</code></pre>
<pre><code>* 调用上一级循环的 `forloop` 模板变量  `forloop.parentloop`  
    修改 `front/views.py` 
</code></pre>
<pre><code>    context = {
      'family': [{'father': '大头爸爸', 'children': ['小头孩儿', '小头女儿']}]
      }
</code></pre>
<pre><code>     修改 `templates/index.html`  
</code></pre>
<pre><code>        {% for who in family %}
            &lt;p&gt;this is &lt;strong style=&quot;color: green&quot;&gt;{{ who.father }}&lt;/strong&gt;&lt;/p&gt;
            {% for child in who.children %}
                &lt;p&gt;{{ child }}&lt;/p&gt;
                &lt;p&gt;{{ forloop.parentloop.first }}&lt;/p&gt;
                &lt;p&gt;{{ forloop.parentloop.last }}&lt;/p&gt;
                &lt;p&gt;{{ forloop.parentloop.counter }}&lt;/p&gt;
                &lt;p&gt;{{ forloop.parentloop.revcounter }}&lt;/p&gt;
            {% endfor %}
        {% endfor %}
</code></pre>
<ul>
<li>
<p><code>for...in</code> 循环字典</p>
<ul>
<li>循环字典 <code>keys</code><br>
修改 <code>front/views.py</code></li>
</ul>
</li>
</ul>
<pre><code>           context = {'student': {
                'name': '道明寺',
                'girl': '杉菜',
                'age': '18',
            }}
</code></pre>
<pre><code>    修改 `templates/index.html`  

    ```
    &lt;ul&gt;
        {% for key in student.keys %}
            &lt;li&gt;{{ key }}&lt;/li&gt;
        {% endfor %}
    &lt;/ul&gt;
    ```      
    
* 循环字典 `values`    

    修改 `templates/index.html`  

    ```
    {% for value in student.values %}
        &lt;li&gt;{{ value }}&lt;/li&gt;
    {% endfor %}
    ```   

* 循环字典 `items`    

    修改 `templates/index.html`  

    ```
    {% for key,value in student.items %}
        &lt;li&gt;{{ key }}--{{ value }}&lt;/li&gt;
    {% endfor %}
    ```   
</code></pre>
<ul>
<li>
<p><code>for...in...empty...</code></p>
<p>修改 <code>front/views.py</code></p>
</li>
</ul>
<pre><code>    context = {
    'comments': []
    }
</code></pre>
<pre><code>修改 `templates/index.html`  
</code></pre>
<pre><code>    {% for comment in comments %}
        {{ comment }}
    {% empty %}
        还没有任何评论
    {% endfor %}
</code></pre>
<ul>
<li>
<p><code>with</code> 标签 （在模板中定义变量）</p>
<p><strong>通过 <code>with</code> 标签定义的变量只能在， 只能在 <code>with</code> 标签包裹的语句块中使用</strong></p>
<p>修改 <code>front/views.py</code></p>
</li>
</ul>
<pre><code>    context = {
        'students': ['孙悟空', '猪八戒', '沙和尚']
    }
</code></pre>
<pre><code>修改 `templates/index.html`  
</code></pre>
<pre><code>    {% with students.0 as monkey %}
        {{ monkey }}
    {% endwith %}

    {% with pig=students.1 %}
        {{ pig }}
    {% endwith %}
</code></pre>
<ul>
<li>
<p><code>url</code> 标签</p>
<p><strong>通过 <code>url</code> 标签 可以把 <code>urls.py</code> 中， 对应的 <code>path</code> 或 <code>re_path</code> 的命名，转换化为浏览器可识别的链接</strong></p>
<p>修改 <code>front/urls.py</code></p>
</li>
</ul>
<pre><code>    from django.urls import path
    from . import views

    app_name = 'front'

    urlpatterns = [
        path('', views.index, name='index'),
        path('book/&lt;book_id&gt;/', views.book, name='book'),
        path('movie/', views.movie, name='movie'),
        path('story/&lt;story_id&gt;/&lt;category&gt;/', views.story, name='story'),
    ]
</code></pre>
<pre><code>修改 `front/views.py`
</code></pre>
<pre><code>    from django.http import HttpResponse
    from django.template.loader import render_to_string


    def index(request):
        return HttpResponse(render_to_string('index.html'))


    def book(request, book_id):
        return HttpResponse('书籍, %s' % book_id)


    def movie(request):
        movie_id = request.GET.get('movie_id')
        return HttpResponse('电影, %s' % movie_id)


    def story(request, story_id, category):
        _type = request.GET.get('type')
        return HttpResponse('故事id: %s, 分类： %s, 类型： %s' % (story_id, category, _type))
</code></pre>
<pre><code>修改 `templates/index.html`  
</code></pre>
<pre><code>    &lt;p&gt;&lt;a href=&quot;{% url 'front:index' %}&quot;&gt;首页&lt;/a&gt;&lt;/p&gt;
    &lt;p&gt;&lt;a href=&quot;{% url 'front:book' book_id=1 %}&quot;&gt;书籍&lt;/a&gt;&lt;/p&gt;
    &lt;p&gt;&lt;a href=&quot;{% url 'front:movie' %}?movie_id=2&quot;&gt;电影&lt;/a&gt;&lt;/p&gt;
    &lt;p&gt;&lt;a href=&quot;{% url 'front:story' story_id=3 category='冒险' %}?type=未知&quot;&gt;故事&lt;/a&gt;&lt;/p&gt;
</code></pre>
<ul>
<li>
<p><code>spaceless</code> 标签 （去除html代码中的空白字符）</p>
<p><strong>下面的 <code>html</code> 模板代码存在很多空白字符，可以通过 <code>spaceless</code> 标签去除</strong></p>
</li>
</ul>
<pre><code>    {% spaceless %}
        &lt;ul&gt;
            &lt;li&gt;
                &lt;a href=&quot;https://www.baidu.com&quot;&gt;
                    百度
                &lt;/a&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    {% endspaceless %}
</code></pre>
<ul>
<li>
<p><code>autoescape</code>标签 （默认开启了特殊字符自动转义）</p>
<p><strong>可以通过设置 <code>autoescape</code> 标签的自动转义 为 <code>off</code>, 关闭自动转义</strong><br>
修改 <code>front/urls.py</code></p>
</li>
</ul>
<pre><code>    urlpatterns = [
        path('', views.index, name='index'),
    ]
</code></pre>
<pre><code>修改 `front/views.py`
</code></pre>
<pre><code>    from django.shortcuts import render


    def index(request):
        return render(request, 'index.html', context={'link': '&lt;p&gt;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&lt;/p&gt;'})
</code></pre>
<pre><code>修改 `templates/index.html`
</code></pre>
<pre><code>    &lt;body&gt;
    {{ link }}
    {% autoescape off %}
        {{ link }}
    {% endautoescape %}
    &lt;/body&gt;
</code></pre>
<ul>
<li><code>verbatim</code> 标签<br>
<strong>当不想要<code>DTL</code>编译 {{}} 或 {%%} 时， 可以通过 <code>verbatim</code> 标签包裹</strong></li>
</ul>
<pre><code>    {% verbatim %}
        {{ 哈哈 }}
        {% 呵呵 %}
    {% endverbatim %}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django ORM常用Field详解]]></title>
        <id>https://xiong-zh.github.io/post/Django-ORM常用Field详解</id>
        <link href="https://xiong-zh.github.io/post/Django-ORM常用Field详解">
        </link>
        <updated>2020-01-18T13:04:14.000Z</updated>
        <summary type="html"><![CDATA[<p>Django ORM常用Field详解</p>
]]></summary>
        <content type="html"><![CDATA[<p>Django ORM常用Field详解</p>
<!-- more -->
<h2 id="一-常用的field">一、常用的<code>Field</code></h2>
<p><code>book/models.py</code></p>
<pre><code>class Fields(models.Model):

    # 映射到数据库中是int类型，可以有自动增长的特性。一般不需要使用这个类型，如果不指定主键，那么模型会自动的生成一个叫做id的自动增长的主键。
    # auto_id = models.AutoField()

    # 64位的整形，类似于AutoField，只不过是产生的数据的范围是从1-9223372036854775807
    id = models.BigAutoField(primary_key=True)

    # 在模型层面接收的是True / False。在数据库层面是tinyint类型 存储的是 0/1。如果没有指定默认值，默认值是None。
    removed = models.BooleanField()

    # 在数据库层面是varchar类型。在Python层面就是普通的字符串。这个类型在使用的时候必须要指定最大的长度，也即必须要传递max_length
    title = models.CharField(max_length=100)

    # 日期类型。在Python中是datetime.date类型，可以记录年月日。在映射到数据库中也是date类型。使用这个Field可以传递以下几个参数：
    #
    # auto_now：最后一次修改时间，可以将这个属性设置为True。
    # auto_now_add：新增时间，可以将这个属性设置为True。
    birth = models.DateField(auto_now_add=True)

    # 日期时间类型，类似于DateField。不仅仅可以存储日期，还可以存储时间。映射到数据库中是datetime类型。这个Field也可以使用auto_now和auto_now_add两个属性。
    created_time = models.DateTimeField(auto_now_add=True)

    # 时间类型。在数据库中是time类型。在Python中是datetime.time类型。
    lunch_time = models.TimeField()

    # 类似于CharField。在数据库底层也是一个varchar类型。最大长度是254个字符。并不验证邮箱格式，配合 ModelForm 使用时，才会与进行邮箱格式验证
    email = models.EmailField()

    # 用来存储文件的。这个请参考后面的文件上传章节部分。
    # file = models.FileField()

    # 用来存储图片文件的。这个请参考后面的图片上传章节部分。
    # image = models.ImageField()

    # 浮点类型。映射到数据库中是double类型。
    price = models.FloatField()

    # 整形。值的区间是-2147483648——2147483647
    age = models.IntegerField()

    # 大整形。值的区间是-9223372036854775808——9223372036854775807。
    total = models.BigIntegerField()

    # 正整形。值的区间是0——2147483647。
    money = models.PositiveIntegerField()

    # 小整形。值的区间是-32768——32767。
    apple = models.SmallIntegerField()

    # 小整形。值的区间是-32768——32767。
    pear = models.PositiveSmallIntegerField()

    # 小整形。值的区间是-32768——32767。
    content = models.TextField()

    # 只能存储uuid格式的字符串。uuid是一个32位的全球唯一的字符串，一般用来作为主键。
    uuid = models.UUIDField()

    # 类似于CharField，只不过只能用来存储url格式的字符串。并且默认的max_length是200。
    url = models.URLField()
</code></pre>
<h2 id="二-注意事项">二、注意事项：</h2>
<ul>
<li>已经将模型映射到数据库后，修改或新增表字段，如果没有提供默认值，在生成迁移文件时，会提供两个选项，让你添加默认值</li>
</ul>
<pre><code>  (myenv) E:\code\PythonEnvs\myenv\book_manager&gt;python manage.py makemigrations
  You are trying to add a non-nullable field 'age' to fields without a default; we can't do that (the database nee
  ds something to populate existing rows).
  Please select a fix:
  1) Provide a one-off default now (will be set on all existing rows with a null value for this column)
  2) Quit, and let me add a default in models.py
</code></pre>
<ul>
<li>
<p>使用 <code>DateField</code>、 <code>DateTimeField</code> 的自动添加时间参数 <code>auto_now_add</code> 或 <code>auto_now</code>， 添加到数据库使用的是 <code>django.utils.timezone.now()</code> , 这是一个  <code>UTC</code> 时间， 为了在模板中正确显示当前时区的时间，需要配置正确时区</p>
<p><code>book_manager/settings.py</code></p>
</li>
</ul>
<pre><code>  TIME_ZONE = 'Asia/Shanghai'
</code></pre>
<hr>
<p><code>book_manager/urls.py</code></p>
<pre><code>  from django.urls import path, include

  urlpatterns = [
      path('', include('book.urls')),
  ]
</code></pre>
<hr>
<p><code>book/urls.py</code></p>
<pre><code>  from django.urls import path
  from . import views

  app_name = 'book'

  urlpatterns = [
      path('', views.index, name='index')
  ]
</code></pre>
<hr>
<p><code>book/models.py</code></p>
<pre><code>  class Book(models.Model):
      id = models.AutoField(primary_key=True)
      title = models.CharField(max_length=100, null=False)
      author = models.CharField(max_length=100, null=False)
      price = models.FloatField(default=0)
      create_time = models.DateTimeField(auto_now_add=True)
</code></pre>
<hr>
<p><code>book/views.py</code></p>
<pre><code>  from django.shortcuts import render
  from . import models

  def index(request):
      book = models.Book(title='精通ES6', author='zhb333', price=333)
      book.save()
      obj = models.Book.objects.get(pk=1)
      # UTC 时间
      return render(request, 'book/index.html', context={'create_time': obj.create_time})
</code></pre>
<hr>
<p><code>book/templates/book/index.html</code></p>
<pre><code>  {#正确配置时区，即便存储在数据库中的时间是UTC时间，模板中也会正确显示配置的时区所对应的时间#}
  {{ create_time }}
</code></pre>
<h2 id="三-其它不常用的-field">三、其它不常用的 <code>Field</code></h2>
<p><strong>可以在 <code>pycharm</code> 中按<code>ctrl</code> 并点击任一个 <code>Field</code>进入所有<code>Field</code>的定义文件查看</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django创建和映射ORM模型到数据库]]></title>
        <id>https://xiong-zh.github.io/post/Django创建和映射ORM模型到数据库</id>
        <link href="https://xiong-zh.github.io/post/Django创建和映射ORM模型到数据库">
        </link>
        <updated>2020-01-18T13:03:08.000Z</updated>
        <summary type="html"><![CDATA[<p>Django创建和映射ORM模型到数据库</p>
]]></summary>
        <content type="html"><![CDATA[<p>Django创建和映射ORM模型到数据库</p>
<!-- more -->
<h2 id="1-新建应用-book">1、新建应用 <code>book</code></h2>
<pre><code>python manage.py startapp book
</code></pre>
<h2 id="2-配置-book-为已安装应用">2、配置 <code>book</code> 为已安装应用</h2>
<p><code>book_manager/settings.py</code></p>
<pre><code>INSTALLED_APPS = [
    'book',
]
</code></pre>
<h2 id="3-创建模型">3、创建模型</h2>
<p><code>book/models.py</code></p>
<pre><code>from django.db import models
# Create your models here.

class Book(models.Model):
    id = models.AutoField(primary_key=True)
    title = models.CharField(max_length=100, null=False)
    author = models.CharField(max_length=100, null=False)
    price = models.FloatField(default=0)
</code></pre>
<h2 id="4-生成数据库迁移文件">4、生成数据库迁移文件</h2>
<pre><code>python manage.py makemigrations
</code></pre>
<h2 id="5-将已安装的应用的迁移文件映射到数据库">5、将已安装的应用的迁移文件映射到数据库</h2>
<pre><code>python manage.py migrate
</code></pre>
<p><strong>注意：</strong></p>
<ol>
<li>
<p>如果在模型中不指定表名，默认是以 应用名_模型名（小写）如：<code>book_book</code> 作为表名</p>
</li>
<li>
<p>模型中默认以 <code>id</code> 作为主键，因此在模型中可以省略主键的定义即：</p>
<p><code>book/models.py</code></p>
</li>
</ol>
<pre><code>    class Book(models.Model):
        title = models.CharField(max_length=100, null=False)
        author = models.CharField(max_length=100, null=False)
        price = models.FloatField(default=0)
</code></pre>
]]></content>
    </entry>
</feed>